---
phase: 01-auth-boundary
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/auth/__init__.py
  - shared/auth/models.py
  - shared/auth/api_keys.py
  - shared/auth/rbac.py
autonomous: true

must_haves:
  truths:
    - "API keys can be generated with cryptographically strong randomness"
    - "API keys are stored SHA-256 hashed, never plaintext"
    - "API key validation returns the associated user with org_id and role"
    - "RBAC permission matrix maps viewer/operator/admin/owner to specific permissions"
    - "Permission checks reject unauthorized roles with 403"
  artifacts:
    - path: "shared/auth/__init__.py"
      provides: "Public API exports for auth package"
    - path: "shared/auth/models.py"
      provides: "Role enum, Organization, User, APIKeyRecord Pydantic models"
      contains: "class Role"
    - path: "shared/auth/api_keys.py"
      provides: "APIKeyStore with generate, validate, rotate, revoke"
      contains: "class APIKeyStore"
    - path: "shared/auth/rbac.py"
      provides: "Permission enum, ROLE_PERMISSIONS dict, require_permission dependency"
      contains: "class Permission"
  key_links:
    - from: "shared/auth/api_keys.py"
      to: "shared/auth/models.py"
      via: "imports Role, User for key validation return"
      pattern: "from .models import"
    - from: "shared/auth/rbac.py"
      to: "shared/auth/models.py"
      via: "imports Role, User for permission checking"
      pattern: "from .models import"
    - from: "shared/auth/api_keys.py"
      to: "SQLite api_keys table"
      via: "parameterized queries with SHA-256 hashed keys"
      pattern: "conn.execute.*api_keys"
---

<objective>
Create the shared/auth/ package with Pydantic models, SQLite-backed API key store, and RBAC permission system.

Purpose: Foundation for all authentication and authorization in NEXUS. Every subsequent auth plan depends on these building blocks.
Output: shared/auth/ package with models.py, api_keys.py, rbac.py ready for middleware integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-boundary/01-RESEARCH.md
@shared/modules/registry.py
@shared/modules/credentials.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth models and API key store</name>
  <files>shared/auth/__init__.py, shared/auth/models.py, shared/auth/api_keys.py</files>
  <action>
Create the `shared/auth/` package directory.

**shared/auth/models.py:**
- `Role(str, Enum)` with values: viewer, operator, admin, owner
- `Organization(BaseModel)` with fields: org_id (str), name (str), created_at (str), plan (str, default="free")
- `User(BaseModel)` with fields: user_id (str), org_id (str), role (Role), email (Optional[str]), created_at (Optional[str])
- `APIKeyRecord(BaseModel)` with fields: key_id (str), org_id (str), role (Role), created_at (str), last_used (Optional[str]), status (str, default="active")
- Do NOT use `from __future__ import annotations` (Pydantic incompatibility)

**shared/auth/api_keys.py:**
- `APIKeyStore` class following the same SQLite pattern as `shared/modules/registry.py`:
  - `__init__(self, db_path="data/api_keys.db")` — creates parent dirs, calls `_init_db()`
  - `_init_db()` — creates tables: `api_keys` (key_id TEXT PK, org_id TEXT NOT NULL, key_hash TEXT NOT NULL UNIQUE, role TEXT DEFAULT 'viewer', user_id TEXT, created_at TEXT, last_used TEXT, status TEXT DEFAULT 'active', rotation_grace_until TEXT, rate_limit INTEGER DEFAULT 1000), `organizations` (org_id TEXT PK, name TEXT, created_at TEXT, plan TEXT DEFAULT 'free'), `users` (user_id TEXT PK, org_id TEXT NOT NULL, email TEXT, role TEXT DEFAULT 'viewer', created_at TEXT, FK org_id -> organizations)
  - Enable WAL mode: `PRAGMA journal_mode=WAL` and `PRAGMA busy_timeout=10000`
  - `generate_key() -> str` — uses `secrets.token_urlsafe(32)`
  - `_hash_key(key: str) -> str` — SHA-256 via hashlib
  - `create_key(org_id: str, role: str = "viewer", user_id: Optional[str] = None) -> tuple[str, str]` — generates key, stores hashed, returns (plaintext_key, key_id). key_id generated via `secrets.token_urlsafe(16)`
  - `validate_key(key_plaintext: str) -> Optional[User]` — hashes input, queries for active or rotation_pending keys, updates last_used timestamp, returns User model or None. Use constant-time comparison pattern: always hash the input even if no match (prevents timing attacks)
  - `rotate_key(org_id: str, key_id: str, grace_days: int = 7) -> tuple[str, str]` — creates new key, marks old as rotation_pending with grace_until timestamp
  - `revoke_key(key_id: str) -> bool` — sets status to 'revoked'
  - `list_keys(org_id: str) -> list[APIKeyRecord]` — lists non-revoked keys for org
  - `create_organization(org_id: str, name: str, plan: str = "free") -> Organization`
  - `get_organization(org_id: str) -> Optional[Organization]`
  - `create_user(user_id: str, org_id: str, role: str = "viewer", email: Optional[str] = None) -> User`

**shared/auth/__init__.py:**
- Export: APIKeyStore, Role, Permission, User, Organization, APIKeyRecord, require_permission, get_current_user
- Use lazy imports or direct imports from submodules
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "from shared.auth.models import Role, User, Organization, APIKeyRecord; print('Models OK'); from shared.auth.api_keys import APIKeyStore; store = APIKeyStore(db_path='/tmp/test_api_keys.db'); key, kid = store.create_key('org-1', 'admin'); user = store.validate_key(key); print(f'Key validated: {user.role}, org={user.org_id}'); assert user.role == Role.ADMIN; assert user.org_id == 'org-1'; print('API Keys OK')"`
  </verify>
  <done>
API key generation returns a plaintext key. Validation of that key returns a User with correct org_id and role. Invalid keys return None. SQLite tables created with WAL mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RBAC permission system</name>
  <files>shared/auth/rbac.py</files>
  <action>
**shared/auth/rbac.py:**
- `Permission(str, Enum)` with values:
  - READ_CONFIG = "read_config"
  - WRITE_CONFIG = "write_config"
  - MANAGE_MODULES = "manage_modules"
  - MANAGE_CREDENTIALS = "manage_credentials"
  - MANAGE_KEYS = "manage_keys"
  - ADMIN_ALL = "admin_all"

- `ROLE_PERMISSIONS: dict[Role, set[Permission]]`:
  - VIEWER: {READ_CONFIG}
  - OPERATOR: {READ_CONFIG, MANAGE_MODULES}
  - ADMIN: {READ_CONFIG, WRITE_CONFIG, MANAGE_MODULES, MANAGE_KEYS}
  - OWNER: all permissions

- `has_permission(role: Role, permission: Permission) -> bool` — checks ROLE_PERMISSIONS mapping

- `get_current_user(request: Request) -> User` — extracts user from `request.state.user`, raises 401 if missing. This is a FastAPI dependency function.

- `require_permission(permission: Permission)` — returns a FastAPI dependency function that:
  1. Calls `get_current_user` via `Depends()`
  2. Checks `has_permission(user.role, permission)`
  3. Raises 403 with detail f"Permission denied: requires {permission.value}" if not authorized
  4. Returns the user if authorized

Import User, Role from `.models`. Import `Depends, HTTPException, Request` from `fastapi`.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "from shared.auth.rbac import Permission, ROLE_PERMISSIONS, has_permission, require_permission; from shared.auth.models import Role; assert has_permission(Role.OWNER, Permission.MANAGE_CREDENTIALS); assert has_permission(Role.ADMIN, Permission.MANAGE_MODULES); assert not has_permission(Role.VIEWER, Permission.MANAGE_MODULES); assert not has_permission(Role.OPERATOR, Permission.WRITE_CONFIG); print('RBAC OK: all permission checks correct')"`
  </verify>
  <done>
Permission matrix correctly enforces: viewer=read-only, operator=read+modules, admin=read+write+modules+keys, owner=everything. require_permission returns a FastAPI-compatible dependency.
  </done>
</task>

</tasks>

<verification>
- `python -c "from shared.auth import APIKeyStore, Role, Permission, User, require_permission"` succeeds
- API key round-trip: generate -> validate -> get User with correct role and org_id
- RBAC: viewer cannot manage_modules, admin can, owner has all permissions
- SQLite database created at specified path with correct schema
</verification>

<success_criteria>
- shared/auth/ package importable with all public symbols
- API key store supports full lifecycle: create, validate, rotate, revoke, list
- RBAC permission matrix matches the spec: viewer < operator < admin < owner
- All SQLite queries use parameterized statements (no string concatenation)
- WAL mode enabled for concurrent access
</success_criteria>

<output>
After completion, create `.planning/phases/01-auth-boundary/01-01-SUMMARY.md`
</output>
