---
phase: 01-auth-boundary
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - shared/auth/middleware.py
  - orchestrator/admin_api.py
  - dashboard_service/main.py
autonomous: true

must_haves:
  truths:
    - "Unauthenticated requests to Admin API return 401"
    - "Unauthenticated requests to Dashboard API return 401"
    - "Health check endpoints remain accessible without auth"
    - "OPTIONS preflight requests are not blocked by auth middleware"
    - "Viewer role cannot enable/disable modules (403)"
    - "Admin role can manage modules and config"
    - "Owner role can manage credentials"
  artifacts:
    - path: "shared/auth/middleware.py"
      provides: "APIKeyAuthMiddleware for FastAPI"
      contains: "class APIKeyAuthMiddleware"
    - path: "orchestrator/admin_api.py"
      provides: "Auth-protected Admin API with RBAC on mutation endpoints"
      contains: "APIKeyAuthMiddleware"
    - path: "dashboard_service/main.py"
      provides: "Auth-protected Dashboard API"
      contains: "APIKeyAuthMiddleware"
  key_links:
    - from: "shared/auth/middleware.py"
      to: "shared/auth/api_keys.py"
      via: "validates X-API-Key header using APIKeyStore"
      pattern: "api_key_store.validate_key"
    - from: "orchestrator/admin_api.py"
      to: "shared/auth/middleware.py"
      via: "app.add_middleware(APIKeyAuthMiddleware)"
      pattern: "add_middleware.*APIKeyAuthMiddleware"
    - from: "orchestrator/admin_api.py"
      to: "shared/auth/rbac.py"
      via: "Depends(require_permission(...)) on mutation endpoints"
      pattern: "require_permission"
    - from: "dashboard_service/main.py"
      to: "shared/auth/middleware.py"
      via: "app.add_middleware(APIKeyAuthMiddleware)"
      pattern: "add_middleware.*APIKeyAuthMiddleware"
---

<objective>
Create auth middleware and wire it into Admin API (port 8003) and Dashboard API (port 8001) with RBAC enforcement on all mutation endpoints.

Purpose: This is the enforcement layer. Without this, the auth package from Plan 01 has no effect. After this plan, unauthenticated requests are rejected and role-based permissions are enforced.
Output: middleware.py + updated admin_api.py and dashboard main.py with auth + RBAC.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-boundary/01-RESEARCH.md
@.planning/phases/01-auth-boundary/01-01-SUMMARY.md
@orchestrator/admin_api.py
@dashboard_service/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth middleware</name>
  <files>shared/auth/middleware.py</files>
  <action>
**shared/auth/middleware.py:**

Create `APIKeyAuthMiddleware(BaseHTTPMiddleware)`:
- Constructor takes `app` and `api_key_store: APIKeyStore` and optional `public_paths: list[str]`
- Default public_paths: ["/health", "/admin/health", "/docs", "/openapi.json", "/redoc", "/metrics"]
- `async dispatch(self, request, call_next)`:
  1. Skip auth for OPTIONS requests (CORS preflight): `if request.method == "OPTIONS": return await call_next(request)`
  2. Skip auth for public_paths: check if `request.url.path` is in public_paths or starts with any public_path prefix
  3. Extract API key from `X-API-Key` header
  4. If missing: return JSONResponse(status_code=401, content={"detail": "Missing API key"})
  5. Call `self.api_key_store.validate_key(api_key)`
  6. If None: return JSONResponse(status_code=401, content={"detail": "Invalid API key"})
  7. Set `request.state.user = user` and `request.state.org_id = user.org_id`
  8. Call and return `await call_next(request)`

Import from starlette.middleware.base import BaseHTTPMiddleware.
Import JSONResponse from starlette.responses (not FastAPI — middleware runs before FastAPI request cycle).

Also add a helper function:
- `create_auth_middleware(app, db_path: str = "data/api_keys.db", public_paths: list[str] = None) -> APIKeyStore` — creates APIKeyStore, adds middleware to app, returns the store instance (for bootstrapping/seeding keys).
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "from shared.auth.middleware import APIKeyAuthMiddleware, create_auth_middleware; print('Middleware imports OK')"`
  </verify>
  <done>
APIKeyAuthMiddleware class exists, importable, takes api_key_store parameter. Skips auth for health/docs/OPTIONS. Returns 401 for missing/invalid keys.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire auth into Admin API and Dashboard with RBAC</name>
  <files>orchestrator/admin_api.py, dashboard_service/main.py</files>
  <action>
**orchestrator/admin_api.py modifications:**

1. Add imports at top:
   ```python
   from shared.auth.middleware import APIKeyAuthMiddleware
   from shared.auth.api_keys import APIKeyStore
   from shared.auth.rbac import require_permission, Permission, get_current_user
   ```

2. Initialize API key store (module-level, like _config_manager pattern):
   ```python
   _api_key_store: Optional[APIKeyStore] = None
   ```

3. Add middleware AFTER the existing CORSMiddleware (order matters: CORS must run first):
   - In `start_admin_server()`, after setting globals, add:
     ```python
     _api_key_store = APIKeyStore(db_path=os.getenv("AUTH_DB_PATH", "data/api_keys.db"))
     _app.add_middleware(APIKeyAuthMiddleware, api_key_store=_api_key_store)
     ```
   - IMPORTANT: Starlette middleware is LIFO — last added runs first. So APIKeyAuthMiddleware must be added AFTER CORSMiddleware in code (which means it runs AFTER CORS in the request pipeline). But since CORSMiddleware is added at module level and APIKeyAuthMiddleware is added in start_admin_server, this is already correct. However, to be safe, move the CORSMiddleware setup into start_admin_server too, or keep it at module level and ensure auth middleware is added later. The safest approach: keep CORS at module level, add auth middleware in start_admin_server() — Starlette processes middleware in reverse order of addition, so auth (added last) wraps CORS (added first), meaning the request goes: auth middleware -> CORS middleware -> route. This is WRONG for preflight. Fix: skip OPTIONS in auth middleware (already done in Task 1).

4. Add RBAC dependencies to mutation endpoints:
   - GET endpoints (read-only): add `user: User = Depends(get_current_user)` — any authenticated user can read
   - PUT/PATCH/DELETE config endpoints: add `user: User = Depends(require_permission(Permission.WRITE_CONFIG))`
   - POST module enable/disable/reload: add `user: User = Depends(require_permission(Permission.MANAGE_MODULES))`
   - DELETE module uninstall: add `user: User = Depends(require_permission(Permission.MANAGE_MODULES))`
   - POST/DELETE credentials: add `user: User = Depends(require_permission(Permission.MANAGE_CREDENTIALS))`
   - POST reload config/system: add `user: User = Depends(require_permission(Permission.WRITE_CONFIG))`

5. Add a bootstrap endpoint for initial key creation (only works when no keys exist):
   ```python
   @_app.post("/admin/bootstrap")
   def bootstrap_admin_key():
       """Create initial admin key. Only works when no keys exist."""
       if _api_key_store is None:
           raise HTTPException(503, "Auth not initialized")
       # Check if any keys exist
       with _api_key_store._connect() as conn:
           count = conn.execute("SELECT COUNT(*) FROM api_keys").fetchone()[0]
       if count > 0:
           raise HTTPException(403, "Bootstrap already complete. Use existing admin key to create new keys.")
       org = _api_key_store.create_organization("default", "Default Organization")
       key, key_id = _api_key_store.create_key("default", "owner")
       return {"api_key": key, "key_id": key_id, "org_id": "default", "role": "owner", "warning": "Store this key securely. It will not be shown again."}
   ```
   Add `/admin/bootstrap` to the public_paths in middleware (no auth required for bootstrap).

6. Add API key management endpoints (protected by MANAGE_KEYS permission):
   - `POST /admin/api-keys` — create new key for org (body: org_id, role)
   - `GET /admin/api-keys` — list keys for authenticated user's org
   - `DELETE /admin/api-keys/{key_id}` — revoke a key
   - `POST /admin/api-keys/{key_id}/rotate` — rotate a key

7. Update `start_admin_server` signature to accept `api_key_store` parameter (optional, for testing). If not provided, create one internally.

**dashboard_service/main.py modifications:**

1. Add imports:
   ```python
   from shared.auth.middleware import APIKeyAuthMiddleware
   from shared.auth.api_keys import APIKeyStore
   ```

2. In the lifespan or app initialization, create APIKeyStore and add middleware:
   - Use the SAME db_path as orchestrator (shared SQLite via volume mount): `os.getenv("AUTH_DB_PATH", "data/api_keys.db")`
   - Add middleware after CORS (same pattern as admin_api.py)
   - Public paths for dashboard: ["/health", "/docs", "/openapi.json", "/metrics", "/stream/pipeline-state"] (SSE stream may need auth later, but keep public for now to avoid breaking Pipeline UI)

3. Keep existing static file serving and bank endpoints accessible to authenticated users (middleware handles auth, no per-endpoint RBAC needed on dashboard for now — it's read-heavy).
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "
from orchestrator.admin_api import _app
routes = [r.path for r in _app.routes if hasattr(r, 'path')]
print('Admin routes:', routes)
assert '/admin/bootstrap' in routes, 'Missing bootstrap endpoint'
assert '/admin/api-keys' in routes or any('api-keys' in r for r in routes), 'Missing key mgmt endpoints'
print('Admin API wiring OK')
"`

Additionally verify import chain: `python -c "from shared.auth.middleware import APIKeyAuthMiddleware; from shared.auth.rbac import require_permission, Permission; print('All auth imports OK')"`
  </verify>
  <done>
Admin API rejects unauthenticated requests with 401 (except /admin/health, /admin/bootstrap). Mutation endpoints enforce RBAC: config writes need WRITE_CONFIG, module ops need MANAGE_MODULES, credential ops need MANAGE_CREDENTIALS. Dashboard API rejects unauthenticated requests with 401 (except /health, /metrics, /docs). Bootstrap endpoint creates initial owner key when no keys exist.
  </done>
</task>

</tasks>

<verification>
- `curl -s http://localhost:8003/admin/modules` returns 401 (no API key)
- `curl -s http://localhost:8003/admin/health` returns 200 (public path)
- `curl -s -X POST http://localhost:8003/admin/bootstrap` returns API key (first time only)
- `curl -s -H "X-API-Key: {key}" http://localhost:8003/admin/modules` returns 200
- `curl -s http://localhost:8001/health` returns 200 (public path on dashboard)
- Creating a viewer key and trying to enable a module returns 403
</verification>

<success_criteria>
- Unauthenticated Admin API requests return 401
- Unauthenticated Dashboard API requests return 401
- Health/docs/metrics endpoints remain public
- Bootstrap creates initial owner key (one-time only)
- RBAC enforced: viewer cannot mutate, admin can manage modules+config, owner can manage credentials
- CORS preflight (OPTIONS) not blocked by auth
</success_criteria>

<output>
After completion, create `.planning/phases/01-auth-boundary/01-02-SUMMARY.md`
</output>
