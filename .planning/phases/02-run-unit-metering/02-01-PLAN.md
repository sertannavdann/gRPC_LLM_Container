---
phase: 02-run-unit-metering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/billing/__init__.py
  - shared/billing/run_units.py
  - shared/billing/usage_store.py
  - shared/billing/quota_manager.py
autonomous: true

must_haves:
  truths:
    - "Run-unit formula: max(cpu_s, gpu_s) × tier_multiplier + tool_overhead"
    - "Usage records persisted in SQLite with WAL mode"
    - "Monthly aggregation query returns total run units for org+period"
    - "Quota check returns allow/deny with remaining budget"
    - "Free tier blocked after 100 run-units/month"
    - "Team tier blocked after 5000 run-units/month"
    - "Enterprise tier has unlimited quota"
  artifacts:
    - path: "shared/billing/__init__.py"
      provides: "Public API exports for billing package"
    - path: "shared/billing/run_units.py"
      provides: "RunUnitCalculator with calculate() and constants"
      contains: "class RunUnitCalculator"
    - path: "shared/billing/usage_store.py"
      provides: "UsageStore with record(), query_usage(), get_period_total()"
      contains: "class UsageStore"
    - path: "shared/billing/quota_manager.py"
      provides: "QuotaManager with check_quota(), get_remaining()"
      contains: "class QuotaManager"
  key_links:
    - from: "shared/billing/quota_manager.py"
      to: "shared/billing/usage_store.py"
      via: "queries period total to check against tier limit"
      pattern: "usage_store.get_period_total"
    - from: "shared/billing/quota_manager.py"
      to: "shared/auth/api_keys.py"
      via: "looks up org plan tier for quota limit"
      pattern: "get_organization"
    - from: "shared/billing/run_units.py"
      to: "constants only"
      via: "pure function, no external dependencies"
      pattern: "TIER_MULTIPLIERS"
---

<objective>
Create the shared/billing/ package with run-unit calculator, SQLite usage store, and quota manager.

Purpose: Foundation for all metering and billing in NEXUS. Every subsequent billing plan depends on these building blocks. The calculator computes normalized compute cost, the store persists it, and the quota manager enforces tier limits.
Output: shared/billing/ package with run_units.py, usage_store.py, quota_manager.py ready for wiring into core/graph.py and orchestrator.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-run-unit-metering/02-RESEARCH.md
@shared/auth/api_keys.py
@shared/auth/models.py
@shared/observability/metrics.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create run-unit calculator</name>
  <files>shared/billing/run_units.py</files>
  <action>
**shared/billing/run_units.py:**

Define constants:
```python
TIER_MULTIPLIERS = {
    "standard": 1.0,
    "heavy": 1.5,
    "ultra": 3.0,
}

TOOL_OVERHEADS = {
    "default": 0.1,
    "sandbox_execute": 0.2,
    "build_module": 0.5,
    "validate_module": 0.3,
    "install_module": 0.2,
    "write_module_code": 0.3,
}
```

Create `RunUnitCalculator` class:
- `calculate(cpu_seconds: float, gpu_seconds: float = 0.0, tier: str = "standard", tool_name: str = "default") -> float`:
  - Formula: `max(cpu_seconds, gpu_seconds) * TIER_MULTIPLIERS.get(tier, 1.0) + TOOL_OVERHEADS.get(tool_name, TOOL_OVERHEADS["default"])`
  - Returns float rounded to 4 decimal places
  - If tier not found, use multiplier 1.0 with a warning log
  - Minimum run-unit per call: 0.01 (floor)

- `calculate_from_latency(latency_ms: float, gpu_seconds: float = 0.0, tier: str = "standard", tool_name: str = "default") -> float`:
  - Convenience method: converts `latency_ms / 1000.0` to cpu_seconds, then calls `calculate()`
  - Use this from `_tools_node` which already tracks `latency_ms`

- `estimate_request_cost(tool_calls: list[dict], tier: str = "standard") -> float`:
  - Convenience: sums run units for a list of tool call results
  - Each dict has at least `tool_name` and `latency_ms`
  - Returns total estimated run units

No external dependencies beyond `logging`. Pure computation module.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "
from shared.billing.run_units import RunUnitCalculator, TIER_MULTIPLIERS, TOOL_OVERHEADS
calc = RunUnitCalculator()

# Basic calculation
ru = calc.calculate(cpu_seconds=0.5, tier='standard', tool_name='default')
expected = max(0.5, 0.0) * 1.0 + 0.1  # 0.6
assert abs(ru - 0.6) < 0.001, f'Expected 0.6, got {ru}'

# Heavy tier
ru_heavy = calc.calculate(cpu_seconds=0.5, tier='heavy', tool_name='default')
expected_heavy = 0.5 * 1.5 + 0.1  # 0.85
assert abs(ru_heavy - 0.85) < 0.001, f'Expected 0.85, got {ru_heavy}'

# Sandbox tool overhead
ru_sandbox = calc.calculate(cpu_seconds=1.0, tier='standard', tool_name='sandbox_execute')
expected_sandbox = 1.0 * 1.0 + 0.2  # 1.2
assert abs(ru_sandbox - 1.2) < 0.001, f'Expected 1.2, got {ru_sandbox}'

# From latency
ru_latency = calc.calculate_from_latency(latency_ms=500.0, tier='standard', tool_name='default')
assert abs(ru_latency - 0.6) < 0.001, f'Expected 0.6, got {ru_latency}'

# Minimum floor
ru_min = calc.calculate(cpu_seconds=0.0, tier='standard', tool_name='default')
assert ru_min >= 0.01, f'Expected >= 0.01, got {ru_min}'

print('RunUnitCalculator OK: all formulas correct')
"
`
  </verify>
  <done>
RunUnitCalculator computes run units with correct formula. Tier multipliers and tool overheads applied correctly. Minimum floor enforced. Convenience methods work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create usage store</name>
  <files>shared/billing/usage_store.py</files>
  <action>
**shared/billing/usage_store.py:**

Create `UsageStore` class following SQLite pattern from `shared/auth/api_keys.py`:
- `__init__(self, db_path: str = "data/billing.db")` — creates parent dirs, calls `_init_db()`
- `_init_db()`:
  - Creates `usage_records` table:
    ```sql
    CREATE TABLE IF NOT EXISTS usage_records (
        id TEXT PRIMARY KEY,
        org_id TEXT NOT NULL,
        user_id TEXT,
        thread_id TEXT,
        tool_name TEXT NOT NULL,
        run_units REAL NOT NULL,
        tier TEXT DEFAULT 'standard',
        cpu_seconds REAL DEFAULT 0.0,
        gpu_seconds REAL DEFAULT 0.0,
        latency_ms REAL DEFAULT 0.0,
        created_at TEXT NOT NULL,
        period TEXT NOT NULL
    )
    ```
  - Creates indexes: `idx_usage_org_period(org_id, period)`, `idx_usage_org_created(org_id, created_at)`
  - Enable WAL mode: `PRAGMA journal_mode=WAL` and `PRAGMA busy_timeout=10000`

- `record(org_id: str, tool_name: str, run_units: float, tier: str = "standard", user_id: Optional[str] = None, thread_id: Optional[str] = None, cpu_seconds: float = 0.0, gpu_seconds: float = 0.0, latency_ms: float = 0.0) -> str`:
  - Generates `id` via `secrets.token_urlsafe(16)`
  - Sets `created_at` to UTC ISO format
  - Sets `period` to `datetime.utcnow().strftime('%Y-%m')`
  - INSERT INTO usage_records
  - Returns the record id

- `get_period_total(org_id: str, period: Optional[str] = None) -> float`:
  - If period is None, use current month `datetime.utcnow().strftime('%Y-%m')`
  - `SELECT COALESCE(SUM(run_units), 0.0) FROM usage_records WHERE org_id = ? AND period = ?`
  - Returns float

- `get_usage_history(org_id: str, start_date: Optional[str] = None, end_date: Optional[str] = None, limit: int = 100) -> list[dict]`:
  - SELECT * FROM usage_records WHERE org_id = ?
  - Optional date range filters on `created_at`
  - ORDER BY created_at DESC LIMIT ?
  - Returns list of dicts

- `get_usage_summary(org_id: str, period: Optional[str] = None) -> dict`:
  - Returns: `{total_run_units, record_count, by_tool: {tool_name: units}, by_tier: {tier: units}, period}`
  - Uses GROUP BY queries

- `_connect(self) -> sqlite3.Connection`:
  - Opens connection to self.db_path
  - Returns connection as context manager

All queries use parameterized statements. Use `secrets` for ID generation and `datetime` for timestamps.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "
from shared.billing.usage_store import UsageStore
import os

db_path = '/tmp/test_usage.db'
if os.path.exists(db_path):
    os.remove(db_path)

store = UsageStore(db_path=db_path)

# Record usage
rid = store.record('org-1', 'weather_query', 0.6, tier='standard', user_id='user-1')
assert rid, 'Record should return an ID'

rid2 = store.record('org-1', 'build_module', 1.5, tier='heavy', user_id='user-1')

# Get period total
total = store.get_period_total('org-1')
assert abs(total - 2.1) < 0.01, f'Expected 2.1, got {total}'

# Different org isolation
store.record('org-2', 'weather_query', 0.3)
total_org2 = store.get_period_total('org-2')
assert abs(total_org2 - 0.3) < 0.01, f'Expected 0.3, got {total_org2}'

# Usage summary
summary = store.get_usage_summary('org-1')
assert summary['record_count'] == 2
assert 'weather_query' in summary['by_tool']

# History
history = store.get_usage_history('org-1')
assert len(history) == 2

print('UsageStore OK: record, query, isolation all working')

os.remove(db_path)
"
`
  </verify>
  <done>
UsageStore persists usage records in SQLite. Period totals aggregate correctly per org. History query returns records with date filtering. Org isolation verified.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create quota manager</name>
  <files>shared/billing/quota_manager.py</files>
  <action>
**shared/billing/quota_manager.py:**

Define tier quota constants:
```python
TIER_QUOTAS = {
    "free": 100.0,        # 100 run-units per month
    "team": 5000.0,       # 5000 run-units per month
    "enterprise": -1.0,   # Unlimited
}
```

Create `QuotaResult` Pydantic model:
- `allowed: bool`
- `current_usage: float`
- `limit: float`
- `remaining: float`
- `period: str`
- `org_id: str`
- `plan: str`

Create `QuotaManager` class:
- `__init__(self, usage_store: UsageStore, api_key_store: Optional[APIKeyStore] = None)`:
  - Stores references; api_key_store is used to look up org plan tier
  - If api_key_store is None, default all orgs to "free" tier

- `check_quota(org_id: str, plan: Optional[str] = None) -> QuotaResult`:
  - If plan not provided, look up via `api_key_store.get_organization(org_id).plan` (if api_key_store available), else default to "free"
  - Get current period total from usage_store
  - Get limit from TIER_QUOTAS (default to free if plan unknown)
  - If limit == -1 (unlimited): always allowed, remaining = float('inf')
  - Else: allowed = current_usage < limit
  - Returns QuotaResult

- `get_remaining(org_id: str, plan: Optional[str] = None) -> float`:
  - Convenience: returns remaining run-units for current period
  - -1.0 means unlimited

- `would_exceed(org_id: str, estimated_units: float, plan: Optional[str] = None) -> bool`:
  - Pre-check: would adding `estimated_units` exceed the quota?
  - Used for pre-flight checks before expensive operations like module builds

Import from `.usage_store` and optionally from `shared.auth.api_keys`.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "
from shared.billing.usage_store import UsageStore
from shared.billing.quota_manager import QuotaManager, QuotaResult, TIER_QUOTAS
import os

db_path = '/tmp/test_quota.db'
if os.path.exists(db_path):
    os.remove(db_path)

store = UsageStore(db_path=db_path)
qm = QuotaManager(usage_store=store)

# Fresh org should be allowed
result = qm.check_quota('org-1', plan='free')
assert result.allowed, 'Fresh org should be allowed'
assert result.remaining == 100.0, f'Expected 100.0 remaining, got {result.remaining}'

# Record usage near limit
for i in range(99):
    store.record('org-1', 'test_tool', 1.0)

result2 = qm.check_quota('org-1', plan='free')
assert result2.allowed, 'Should still be allowed at 99/100'
assert abs(result2.remaining - 1.0) < 0.1

# Exceed limit
store.record('org-1', 'test_tool', 1.0)
result3 = qm.check_quota('org-1', plan='free')
assert not result3.allowed, 'Should be blocked at 100/100'

# Enterprise unlimited
result4 = qm.check_quota('org-1', plan='enterprise')
assert result4.allowed, 'Enterprise should always be allowed'

# would_exceed pre-check
assert qm.would_exceed('org-1', 1.0, plan='free'), 'Should exceed free quota'
assert not qm.would_exceed('org-1', 1.0, plan='enterprise'), 'Enterprise never exceeds'

print('QuotaManager OK: enforcement at boundaries, unlimited enterprise, pre-check working')

os.remove(db_path)
"
`
  </verify>
  <done>
QuotaManager correctly enforces tier limits. Free tier blocked at 100 run-units/month. Enterprise has unlimited quota. Pre-flight check (`would_exceed`) works for expensive operations. QuotaResult model provides full context for API responses.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create billing package init</name>
  <files>shared/billing/__init__.py</files>
  <action>
**shared/billing/__init__.py:**
- Export: `RunUnitCalculator`, `TIER_MULTIPLIERS`, `TOOL_OVERHEADS`, `UsageStore`, `QuotaManager`, `QuotaResult`, `TIER_QUOTAS`
- Use direct imports from submodules
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "from shared.billing import RunUnitCalculator, UsageStore, QuotaManager, QuotaResult, TIER_QUOTAS, TIER_MULTIPLIERS, TOOL_OVERHEADS; print('Billing package imports OK')"`
  </verify>
  <done>
shared/billing/ package importable with all public symbols.
  </done>
</task>

</tasks>

<verification>
- `python -c "from shared.billing import RunUnitCalculator, UsageStore, QuotaManager"` succeeds
- Run-unit formula: `max(0.5, 0.0) * 1.0 + 0.1 = 0.6` (standard, default tool)
- Usage store round-trip: record → get_period_total → correct sum
- Quota enforcement: free tier blocked at 100, team at 5000, enterprise unlimited
- All SQLite queries use parameterized statements
- WAL mode enabled for concurrent access
</verification>

<success_criteria>
- shared/billing/ package importable with all public symbols
- RunUnitCalculator produces correct values for all tier × tool combinations
- UsageStore persists and queries usage records with org isolation
- QuotaManager enforces tier limits at exact boundaries (100/5000/unlimited)
- All SQLite queries use parameterized statements (no string concatenation)
- WAL mode enabled for concurrent access
</success_criteria>

<output>
After completion, create `.planning/phases/02-run-unit-metering/02-01-SUMMARY.md`
</output>
