---
phase: 02-run-unit-metering
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - orchestrator/admin_api.py
  - tests/unit/test_billing.py
  - tests/auth/test_billing_integration.py
  - Makefile
autonomous: true

must_haves:
  truths:
    - "GET /admin/billing/usage returns current period usage for authenticated org"
    - "GET /admin/billing/usage/history returns historical records with date filtering"
    - "GET /admin/billing/quota returns remaining quota and plan details"
    - "Billing endpoints require authentication (401 without API key)"
    - "Billing endpoints respect org_id scoping (org A cannot see org B usage)"
    - "Unit tests cover calculator, store, and quota at boundaries"
    - "Integration tests verify end-to-end billing flow"
    - "make test-billing runs all billing tests"
  artifacts:
    - path: "orchestrator/admin_api.py"
      provides: "Billing API endpoints"
      contains: "/admin/billing/"
    - path: "tests/unit/test_billing.py"
      provides: "Unit tests for billing package"
      contains: "test_run_unit_calculator"
    - path: "tests/auth/test_billing_integration.py"
      provides: "Integration tests for billing endpoints"
      contains: "test_billing_usage_endpoint"
  key_links:
    - from: "orchestrator/admin_api.py"
      to: "shared/billing/usage_store.py"
      via: "queries usage data for API responses"
      pattern: "usage_store.get_period_total"
    - from: "orchestrator/admin_api.py"
      to: "shared/billing/quota_manager.py"
      via: "queries quota for API response"
      pattern: "quota_manager.check_quota"
    - from: "orchestrator/admin_api.py"
      to: "shared/auth/rbac.py"
      via: "billing endpoints require READ_CONFIG permission"
      pattern: "require_permission"
---

<objective>
Add billing API endpoints to Admin API, create comprehensive tests, and wire a Makefile target.

Purpose: Users and admin dashboards need to query usage data and quota status. Tests ensure the billing system works correctly at boundaries and prevents regressions. This completes the Phase 2 deliverables.
Output: 3 new billing endpoints on Admin API, comprehensive test suite, `make test-billing` target.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-run-unit-metering/02-RESEARCH.md
@.planning/phases/02-run-unit-metering/02-01-PLAN.md
@.planning/phases/02-run-unit-metering/02-02-PLAN.md
@orchestrator/admin_api.py
@shared/billing/run_units.py
@shared/billing/usage_store.py
@shared/billing/quota_manager.py
@tests/unit/test_auth.py
@tests/auth/test_auth_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add billing API endpoints to Admin API</name>
  <files>orchestrator/admin_api.py</files>
  <action>
**orchestrator/admin_api.py modifications:**

1. Add imports:
```python
from shared.billing.usage_store import UsageStore
from shared.billing.quota_manager import QuotaManager, QuotaResult
```

2. Initialize billing components in module-level or in `start_admin_server()`:
```python
_usage_store: Optional[UsageStore] = None
_quota_manager: Optional[QuotaManager] = None
```
In `start_admin_server()`:
```python
_usage_store = UsageStore(db_path=os.getenv("BILLING_DB_PATH", "data/billing.db"))
_quota_manager = QuotaManager(usage_store=_usage_store, api_key_store=_api_key_store)
```

3. Add billing endpoints (require authentication, READ_CONFIG permission):

```python
@_app.get("/admin/billing/usage")
def get_billing_usage(
    period: Optional[str] = None,
    user: User = Depends(get_current_user),
):
    """Get current period usage for authenticated user's org."""
    if _usage_store is None:
        raise HTTPException(503, "Billing not initialized")
    summary = _usage_store.get_usage_summary(user.org_id, period=period)
    return summary

@_app.get("/admin/billing/usage/history")
def get_billing_history(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    limit: int = 100,
    user: User = Depends(get_current_user),
):
    """Get usage history for authenticated user's org."""
    if _usage_store is None:
        raise HTTPException(503, "Billing not initialized")
    records = _usage_store.get_usage_history(
        user.org_id,
        start_date=start_date,
        end_date=end_date,
        limit=min(limit, 1000),  # Cap at 1000
    )
    return {"records": records, "count": len(records)}

@_app.get("/admin/billing/quota")
def get_billing_quota(
    user: User = Depends(get_current_user),
):
    """Get remaining quota for authenticated user's org."""
    if _quota_manager is None:
        raise HTTPException(503, "Billing not initialized")
    result = _quota_manager.check_quota(user.org_id)
    return result.model_dump() if hasattr(result, 'model_dump') else result.dict()
```

Note: These endpoints use `get_current_user` (any authenticated user can view their own org's billing). org_id comes from `user.org_id` — org isolation is automatic via auth middleware.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "
from orchestrator.admin_api import _app
routes = [r.path for r in _app.routes if hasattr(r, 'path')]
billing_routes = [r for r in routes if 'billing' in r]
print(f'Billing routes: {billing_routes}')
assert '/admin/billing/usage' in billing_routes, 'Missing /admin/billing/usage'
assert '/admin/billing/quota' in billing_routes, 'Missing /admin/billing/quota'
print('Billing endpoints registered OK')
"`
  </verify>
  <done>
Three billing endpoints added: /admin/billing/usage (current period summary), /admin/billing/usage/history (historical records), /admin/billing/quota (remaining quota). All auto-scoped by org_id from authenticated user.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create billing unit tests</name>
  <files>tests/unit/test_billing.py</files>
  <action>
**tests/unit/test_billing.py:**

Create comprehensive unit tests covering:

1. **RunUnitCalculator tests:**
   - `test_basic_calculation` — standard tier, default tool
   - `test_heavy_tier_multiplier` — heavy tier increases cost
   - `test_ultra_tier_multiplier` — ultra tier at 3x
   - `test_sandbox_tool_overhead` — sandbox_execute overhead = 0.2
   - `test_build_module_overhead` — build_module overhead = 0.5
   - `test_gpu_seconds_takes_max` — gpu_seconds > cpu_seconds uses gpu
   - `test_calculate_from_latency` — convenience method converts ms to seconds
   - `test_minimum_floor` — zero latency still gives minimum 0.01
   - `test_unknown_tier_defaults_to_1x` — unknown tier logs warning, uses 1.0
   - `test_unknown_tool_uses_default_overhead` — unknown tool uses 0.1
   - `test_estimate_request_cost` — sums multiple tool calls

2. **UsageStore tests:**
   - `test_record_and_retrieve` — basic round-trip
   - `test_period_total_aggregation` — multiple records sum correctly
   - `test_org_isolation` — org A records not visible in org B totals
   - `test_usage_history_ordering` — DESC by created_at
   - `test_usage_history_date_filter` — start_date/end_date filtering
   - `test_usage_summary_by_tool` — by_tool breakdown correct
   - `test_usage_summary_by_tier` — by_tier breakdown correct
   - `test_empty_org_returns_zero` — no records = 0.0 total

3. **QuotaManager tests:**
   - `test_fresh_org_allowed` — no usage = allowed
   - `test_free_tier_at_boundary` — 99 units = allowed, 100 = blocked
   - `test_team_tier_at_boundary` — 4999 = allowed, 5000 = blocked
   - `test_enterprise_unlimited` — always allowed regardless of usage
   - `test_would_exceed_precheck` — predicts quota breach
   - `test_default_plan_is_free` — no api_key_store defaults to free

Use `pytest` with `tmp_path` fixture for SQLite databases. Each test class gets its own temp database.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && cd tests && python -m pytest unit/test_billing.py -v --tb=short -x 2>&1 | head -80`
  </verify>
  <done>
Comprehensive unit tests for all billing components: calculator formulas, store persistence, quota enforcement at boundaries. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create billing integration tests</name>
  <files>tests/auth/test_billing_integration.py</files>
  <action>
**tests/auth/test_billing_integration.py:**

Integration tests that exercise the full billing flow:

1. **test_billing_usage_endpoint** — authenticate, make tool calls that record usage, query /admin/billing/usage, verify totals
2. **test_billing_quota_endpoint** — query /admin/billing/quota, verify remaining matches expectation
3. **test_billing_history_endpoint** — record multiple usage entries, query history with date filters
4. **test_billing_requires_auth** — unauthenticated request to /admin/billing/usage returns 401
5. **test_billing_org_isolation** — org A usage not visible in org B billing response
6. **test_quota_enforcement_blocks_request** — fill org to quota limit, verify next request is blocked

Use `TestClient` from FastAPI (like the auth integration tests). Set up a temporary SQLite database for billing. Create API keys and authenticate requests.

Follow the same patterns as `tests/auth/test_auth_integration.py` for test setup, authentication, and teardown.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && cd tests && python -m pytest auth/test_billing_integration.py -v --tb=short -x 2>&1 | head -60`
  </verify>
  <done>
Integration tests verify full billing flow end-to-end: API endpoints, auth requirement, org isolation, quota enforcement. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add test-billing Makefile target</name>
  <files>Makefile</files>
  <action>
Add to Makefile:

1. Add `test-billing` to the `.PHONY` declaration (in the test line, alongside test-unit, test-integration, etc.)

2. Add help entry in the Testing section:
```makefile
@printf '  $(CYAN)make test-billing$(RESET)       - Run billing unit + integration tests\n'
```

3. Add target:
```makefile
test-billing:
	@printf '$(CYAN)Running billing unit + integration tests...$(RESET)\n'
	@cd tests && python -m pytest unit/test_billing.py auth/test_billing_integration.py -v --tb=short
```
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && make test-billing`
  </verify>
  <done>
`make test-billing` runs both unit and integration test suites for billing. Exit code 0 on success, non-zero on failure.
  </done>
</task>

</tasks>

<verification>
- `curl -H "X-API-Key: $KEY" http://localhost:8003/admin/billing/usage` returns JSON with usage summary
- `curl -H "X-API-Key: $KEY" http://localhost:8003/admin/billing/quota` returns remaining quota
- `curl http://localhost:8003/admin/billing/usage` returns 401 (no auth)
- `make test-billing` exits 0
- Unit tests cover formula, store, and quota at exact boundaries
</verification>

<success_criteria>
- Three billing API endpoints accessible to authenticated users
- Billing data automatically scoped by org_id from auth middleware
- Comprehensive unit tests for calculator, store, and quota manager
- Integration tests verify full billing flow through API
- `make test-billing` runs all billing tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-run-unit-metering/02-03-SUMMARY.md`
</output>
