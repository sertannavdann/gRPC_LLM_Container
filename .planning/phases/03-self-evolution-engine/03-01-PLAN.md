---
phase: 03-self-evolution-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/modules/contracts.py
  - shared/modules/manifest_schema.json
  - shared/modules/artifacts.py
  - shared/modules/output_contract.py
  - tests/unit/modules/test_contracts_static.py
  - tests/unit/modules/test_manifest_schema.py
  - tests/unit/modules/test_artifact_bundle.py
  - tests/unit/modules/test_output_contract.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "A module is exactly {manifest.json, adapter.py, test_adapter.py} (+ optional README) and nothing else"
    - "The generator output contract is strict and machine-validated (stage, changed_files, assumptions, rationale, policy, validation_report)"
    - "Every attempt produces an immutable, content-addressed artifact bundle (sha256) before any install"
    - "Canonical adapter output envelope is defined for orchestrator + bridge + UI + metering (single schema)"
    - "No markdown fences allowed in generated file content"
    - "changed_files only within allowlisted paths"
  artifacts:
    - path: "shared/modules/contracts.py"
      provides: "Single source of truth for adapter/build contracts"
      contains: "AdapterContractSpec, GeneratorResponseContract"
    - path: "shared/modules/manifest_schema.json"
      provides: "Versioned manifest validation schema"
      contains: "$id, $schema"
    - path: "shared/modules/artifacts.py"
      provides: "Content-addressed artifact bundle builder + index model"
      contains: "bundle_sha256, ArtifactIndex"
    - path: "shared/modules/output_contract.py"
      provides: "Canonical AdapterRunResult envelope for all consumers"
      contains: "AdapterRunResult"
  key_links:
    - from: "shared/modules/contracts.py"
      to: "tools/builtin/module_builder.py"
      via: "builder enforces GeneratorResponseContract on LLM outputs"
      pattern: "validate_response"
    - from: "shared/modules/output_contract.py"
      to: "orchestrator/orchestrator_service.py"
      via: "orchestrator consumes canonical run envelope"
      pattern: "AdapterRunResult"
    - from: "shared/modules/artifacts.py"
      to: "tools/builtin/module_installer.py"
      via: "installer verifies bundle_sha256 attestation"
      pattern: "verify_bundle"
---

<objective>
Freeze the core contracts that everything else depends on.

Purpose: Define the module file layout, manifest schema, generator response schema, artifact bundle format, and canonical adapter run-result envelope — all as single-source-of-truth contracts with tests.
Output: Every downstream plan (gateway, sandbox, repair loop, install) imports these contracts rather than defining its own.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-self-evolution-engine/03-RESEARCH.md
@shared/modules/manifest.py
@shared/modules/registry.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Manifest JSON schema</name>
  <files>shared/modules/manifest_schema.json, tests/unit/modules/test_manifest_schema.py</files>
  <action>
Implement JSON schema for manifest.json:
- Required fields: module_id, version, category, platform, entrypoint, capabilities
- Optional fields: auth, pagination, rate_limits, outputs, artifacts, description
- Versioned $id for schema evolution tracking
- Strict additionalProperties: false

Add unit tests that validate:
- A valid manifest passes
- Missing required fields are rejected
- Unknown fields are rejected
- Version format enforcement
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/unit/modules/test_manifest_schema.py -v --tb=short`
  </verify>
  <done>
manifest_schema.json exists, is strict, has a versioned $id, and deterministically validates sample manifests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Builder + adapter contract specs</name>
  <files>shared/modules/contracts.py, tests/unit/modules/test_contracts_static.py</files>
  <action>
Define two contract specs:

AdapterContractSpec:
- Required base class methods (fetch, transform, get_schema)
- Registration decorator import + usage rule
- Forbidden imports baseline (os.system, subprocess, eval, exec, __import__)
- AST-based static checker helpers (imports, decorator present, required methods exist)

GeneratorResponseContract:
- Required fields: stage, module, changed_files, deleted_files, assumptions, rationale, policy, validation_report
- "No markdown fences" rule for changed_files content
- Path allowlist enforcement (only module directory paths)
- Size bounds: max_changed_files, max_patch_bytes

Add unit tests enforcing invariants: valid payloads pass, invalid are rejected with specific error codes.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/unit/modules/test_contracts_static.py -v --tb=short`
  </verify>
  <done>
contracts.py defines generator contract + adapter contract spec; unit tests enforce all invariants including markdown fence rejection and path allowlist.
  </done>
</task>

<task type="auto">
  <name>Task 3: Content-addressed artifact bundles</name>
  <files>shared/modules/artifacts.py, tests/unit/modules/test_artifact_bundle.py</files>
  <action>
Implement artifact bundle system:
- Bundle builder: deterministic file ordering, sha256 per file, sha256 for full bundle
- ArtifactIndex model: job_id, attempt_id, bundle_sha256, file list with individual hashes + sizes, created_at
- Self-check function: verify bundle identity is stable for identical inputs
- Bundle comparison: diff two bundles to identify changed files

Add unit tests:
- Stable sha256 for identical inputs (determinism proof)
- Different content produces different hash
- ArtifactIndex serialization round-trip
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/unit/modules/test_artifact_bundle.py -v --tb=short`
  </verify>
  <done>
artifacts.py builds content-addressed bundles and produces an index record with file hashes + sizes. Self-check proves determinism.
  </done>
</task>

<task type="auto">
  <name>Task 4: Canonical adapter output envelope</name>
  <files>shared/modules/output_contract.py, tests/unit/modules/test_output_contract.py</files>
  <action>
Define the canonical envelope consumed by orchestrator, bridge, UI, and metering:
- contract: name, version, schema_id
- run: run_id, org_id, module_id, version, capability, timestamps
- status: success | partial | error
- data_points[]: typed payloads with schema references
- artifacts[]: charts, files, logs with metadata (mime, bytes, sha256)
- errors[]: standardized error codes (connectivity, auth, rate_limit, schema, internal)
- metering: run_units, tokens, duration
- trace: trace_id, span_id

Implement as Pydantic models with JSON schema export.
Add tests validating example payloads for success, partial, and error cases.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/unit/modules/test_output_contract.py -v --tb=short`
  </verify>
  <done>
output_contract.py defines AdapterRunResult envelope. All consumers (orchestrator, bridge, UI, metering) can import and validate against a single schema.
  </done>
</task>

</tasks>

<verification>
- manifest_schema.json validates correct manifests and rejects invalid ones
- contracts.py rejects markdown fences, path violations, and missing fields
- artifacts.py produces stable hashes for identical inputs
- output_contract.py serializes and deserializes without data loss
- All four modules are importable and have no circular dependencies
</verification>

<success_criteria>
- Contracts are "single source of truth" — tested and referenced by all downstream plans
- REQ-013 foundation: module scaffold format is fixed (manifest.json + adapter.py + test_adapter.py)
- REQ-016 foundation: deterministic artifact identity and canonical output schema enable auditable validation
</success_criteria>

<output>
After completion, create `.planning/phases/03-self-evolution-engine/03-01-SUMMARY.md`
</output>
