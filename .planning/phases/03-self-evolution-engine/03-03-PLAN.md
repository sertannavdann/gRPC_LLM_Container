---
phase: 03-self-evolution-engine
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - sandbox_service/policy.py
  - sandbox_service/runner.py
  - sandbox_service/sandbox_service.py
  - tools/builtin/module_validator.py
  - tests/integration/sandbox/test_import_allowlist.py
  - tests/integration/sandbox/test_network_modes.py
  - tests/integration/sandbox/test_artifact_capture.py
  - tests/unit/test_module_validator_policy.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Generated code is executed only inside sandbox for runtime tests (never on host)"
    - "Default network mode is blocked; allowlist mode is explicit and logged"
    - "Import allowlist is enforced both statically (AST) and at runtime (import hook)"
    - "Stdout/stderr + junit + structured run results are captured as artifacts per attempt"
    - "Policy violations fail closed — no fallback, no override, installation blocked"
    - "Resource caps enforced: timeout, memory, process limits per sandbox execution"
  artifacts:
    - path: "sandbox_service/policy.py"
      provides: "Execution and egress policy profiles with network modes"
      contains: "NetworkPolicy, ImportPolicy, ResourcePolicy"
    - path: "sandbox_service/runner.py"
      provides: "Structured sandbox execution with artifact capture"
      contains: "SandboxRunner, ExecutionResult"
    - path: "tools/builtin/module_validator.py"
      provides: "Multi-stage validator with merged static + runtime report"
      contains: "validate_module, ValidationReport"
  key_links:
    - from: "tools/builtin/module_validator.py"
      to: "sandbox_service/sandbox_service.py"
      via: "validator invokes sandbox for runtime test execution"
      pattern: "ExecuteCode"
    - from: "sandbox_service/policy.py"
      to: "shared/modules/contracts.py"
      via: "policy references AdapterContractSpec forbidden imports"
      pattern: "FORBIDDEN_IMPORTS"
    - from: "tools/builtin/module_validator.py"
      to: "shared/modules/artifacts.py"
      via: "validator stores logs + junit + report as artifacts per attempt"
      pattern: "ArtifactIndex"
---

<objective>
Make runtime validation real: deterministic sandbox runs with policy enforcement and artifact capture.

Purpose: Ensure generated adapters are validated in isolation with enforced network, import, and resource policies, producing machine-readable reports with actionable fix hints.
Output: Validator returns a single merged ValidationReport (static + runtime) with artifacts stored per attempt.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/03-self-evolution-engine/03-RESEARCH.md
@sandbox_service/sandbox_service.py
@tools/builtin/module_validator.py
@shared/modules/contracts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sandbox policy profiles</name>
  <files>sandbox_service/policy.py, sandbox_service/sandbox_service.py, tests/unit/test_module_validator_policy.py</files>
  <action>
Implement sandbox policy system:

NetworkPolicy:
- default: no external network (all egress blocked)
- integration: strict domain allowlist only (logged)
- blocked domains always include: localhost, 169.254.*, internal ranges

ImportPolicy:
- Extend existing SAFE_IMPORTS with module-build additions: httpx, aiohttp, csv, pydantic, pytest, unittest.mock
- Forbidden list from AdapterContractSpec: os.system, subprocess, eval, exec, __import__, ctypes
- Category-based allowlists (standard_lib, http_clients, testing, data_processing)

ResourcePolicy:
- timeout: default 30s, max 60s (configurable per policy profile)
- memory: default 256MB, max 512MB
- processes: max 4 per execution

Wire policy profiles into existing sandbox_service.py without breaking current code_executor usage.

Add unit tests for policy creation, merge, and enforcement boundaries.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/unit/test_module_validator_policy.py -v --tb=short`
  </verify>
  <done>
Sandbox enforces deny-by-default policy with configurable profiles. Policy violations are non-bypassable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Static + runtime import enforcement</name>
  <files>sandbox_service/runner.py, sandbox_service/policy.py, tests/integration/sandbox/test_import_allowlist.py</files>
  <action>
Implement dual-layer import enforcement:

Static layer (pre-execution):
- AST visitor that extracts all import statements from generated code
- Check against ImportPolicy allowlist
- Reject with specific error: which import, which file, which policy rule

Runtime layer (during execution):
- Custom import hook that intercepts __import__ calls
- Block forbidden modules at runtime even if AST check is bypassed
- Log all import attempts for audit trail

Add integration tests:
- Allowed import succeeds
- Forbidden import (subprocess) blocked statically
- Dynamic import (__import__('os')) blocked at runtime
- Import of non-existent module handled gracefully
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/integration/sandbox/test_import_allowlist.py -v --tb=short`
  </verify>
  <done>
Import allowlist is enforced both statically (AST) and at runtime (import hook). Neither layer can be bypassed independently.
  </done>
</task>

<task type="auto">
  <name>Task 3: Validator merge + artifact capture</name>
  <files>tools/builtin/module_validator.py, sandbox_service/runner.py, tests/integration/sandbox/test_artifact_capture.py</files>
  <action>
Expand validator to produce merged ValidationReport:

Static checks (run on host, no sandbox needed):
- AST contract compliance (required methods, decorator, imports)
- Manifest schema validation (against manifest_schema.json)
- Path allowlist check

Runtime checks (sandbox only):
- Execute test_adapter.py in sandbox
- Capture stdout, stderr, junit XML (if pytest)
- Record timing, resource usage, exit code

Merged report:
- status: VALIDATED | FAILED | ERROR
- static_results: list of check name + pass/fail + details
- runtime_results: test counts, failures, errors
- fix_hints: structured hints with category (import_violation, test_failure, schema_error, etc.) and targeted action
- artifacts: references to captured logs, junit, report files

Store all artifacts using ArtifactIndex from shared/modules/artifacts.py.

Add integration tests:
- Clean adapter produces VALIDATED with all artifacts
- Bad import produces FAILED with fix hint
- Test failure produces FAILED with junit artifact
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/integration/sandbox/test_artifact_capture.py -v --tb=short`
  </verify>
  <done>
Validator returns a single merged ValidationReport (static + runtime). Artifacts stored per attempt: logs, junit, policy report, resource usage.
  </done>
</task>

<task type="auto">
  <name>Task 4: Network mode enforcement</name>
  <files>sandbox_service/runner.py, sandbox_service/policy.py, tests/integration/sandbox/test_network_modes.py</files>
  <action>
Implement network mode enforcement in sandbox runner:
- Default mode: block all outbound connections
- Integration mode: allow only domains in explicit allowlist
- Log all connection attempts (allowed and blocked) for audit
- Connection attempt to blocked host returns clear error (not timeout)

Add integration tests:
- Default mode: HTTP request to external host is blocked
- Integration mode: allowed host succeeds, non-allowed host blocked
- DNS resolution blocked in default mode
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/integration/sandbox/test_network_modes.py -v --tb=short`
  </verify>
  <done>
Network modes are enforced and logged. Default is fully blocked, integration mode uses strict allowlist.
  </done>
</task>

</tasks>

<verification>
- Generated code never executes on host — only in sandbox
- Forbidden imports blocked both statically and at runtime
- Network requests blocked in default mode
- Validator produces merged static + runtime report
- All artifacts (logs, junit, reports) stored per attempt
- Policy violations are terminal — no override path
</verification>

<success_criteria>
- REQ-016: sandbox-only execution + deterministic artifacts + reports
- REQ-013: runtime validation is a required step before install
- Validator is ready to be called in the repair loop (Plan 03-04)
</success_criteria>

<output>
After completion, create `.planning/phases/03-self-evolution-engine/03-03-SUMMARY.md`
</output>
