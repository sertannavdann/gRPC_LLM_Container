---
phase: 03-self-evolution-engine
plan: 04
type: execute
wave: 2
depends_on: ["03-02", "03-03"]
files_modified:
  - tools/builtin/module_builder.py
  - tools/builtin/module_installer.py
  - shared/modules/audit.py
  - shared/modules/manifest.py
  - orchestrator/orchestrator_service.py
  - tests/integration/self_evolution/test_repair_loop_max_10.py
  - tests/integration/self_evolution/test_repeated_failure_fingerprint.py
  - tests/integration/install/test_validated_only_guard.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Repair loop is bounded to 10 attempts and stops early on repeated identical failure fingerprints"
    - "Each attempt is immutable: bundle_sha256 + validation report + logs are never mutated"
    - "Install is impossible unless validation status is VALIDATED and attestation matches bundle_sha256"
    - "Repair prompt input is strictly: fix_hints + failing logs + relevant file snapshots (no stale context)"
    - "Builder uses stage pipeline: scaffold -> implement -> tests -> repair"
    - "Transient failures are retryable; policy/security failures are terminal (no repair attempt)"
  artifacts:
    - path: "tools/builtin/module_builder.py"
      provides: "Stage-based generation with bounded repair loop"
      contains: "build_module, repair_stage, MAX_ATTEMPTS"
    - path: "tools/builtin/module_installer.py"
      provides: "Validated-only install guard with attestation check"
      contains: "install_module, verify_attestation"
    - path: "shared/modules/audit.py"
      provides: "Per-attempt audit records with immutable artifact references"
      contains: "AttemptRecord, BuildAuditLog"
  key_links:
    - from: "tools/builtin/module_builder.py"
      to: "shared/providers/llm_gateway.py"
      via: "builder requests code generation via gateway"
      pattern: "gateway.generate(purpose='codegen')"
    - from: "tools/builtin/module_builder.py"
      to: "tools/builtin/module_validator.py"
      via: "builder calls validator after each generation attempt"
      pattern: "validate_module"
    - from: "tools/builtin/module_builder.py"
      to: "shared/providers/llm_gateway.py"
      via: "repair stage calls gateway with fix hints"
      pattern: "gateway.generate(purpose='repair')"
    - from: "tools/builtin/module_installer.py"
      to: "shared/modules/artifacts.py"
      via: "installer verifies bundle_sha256 matches validated attestation"
      pattern: "verify_bundle"
    - from: "orchestrator/orchestrator_service.py"
      to: "tools/builtin/module_builder.py"
      via: "orchestrator invokes build_module as registered tool"
      pattern: "register(build_module)"
---

<objective>
Wire together the full self-correction pipeline: LLM gateway -> patch output -> policy checks -> sandbox -> validator -> (repair loop) -> install-on-pass.

Purpose: Complete the NL-to-installed-module flow with bounded self-repair, immutable attempt tracking, and attestation-based install guard.
Output: A deliberately failing adapter can be repaired into VALIDATED within 10 attempts (or fail with diagnostics). Installer blocks non-validated artifacts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/03-self-evolution-engine/03-RESEARCH.md
@tools/builtin/module_builder.py
@tools/builtin/module_validator.py
@tools/builtin/module_installer.py
@shared/providers/llm_gateway.py
@shared/modules/contracts.py
@shared/modules/artifacts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stage-based builder pipeline</name>
  <files>tools/builtin/module_builder.py, shared/modules/manifest.py</files>
  <action>
Refactor module_builder.py to implement explicit stage pipeline:

scaffold stage:
- Create module directory with manifest.json + stub adapter.py + base test_adapter.py
- Use templates from shared/modules/templates/
- Populate manifest from NL intent (category, platform, capabilities)

implement stage:
- Call gateway.generate(purpose="codegen") with scaffold context
- Apply API-specific fetch/transform logic via patch
- Validate response against GeneratorResponseContract

tests stage:
- Call gateway.generate(purpose="codegen") with implementation context
- Generate test_adapter.py with generic + feature-specific suites
- Validate test file against contract

Each stage produces an immutable artifact bundle (ArtifactIndex).
Track current attempt number and per-attempt references in build session state.
Idempotent job identity via normalized request hash.
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -c "from tools.builtin.module_builder import build_module; print('builder import ok')"`
  </verify>
  <done>
Builder supports full stage pipeline (scaffold -> implement -> tests) with deterministic template generation and artifact tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bounded repair loop with failure fingerprinting</name>
  <files>tools/builtin/module_builder.py, shared/modules/audit.py, tests/integration/self_evolution/test_repair_loop_max_10.py, tests/integration/self_evolution/test_repeated_failure_fingerprint.py</files>
  <action>
Implement repair loop:

repair stage:
- Input: fix_hints from validator + failing test logs + current file snapshots (no stale context)
- Call gateway.generate(purpose="repair") with delta-only prompt contract
- Apply patch to only changed files
- Re-validate in sandbox

Loop control:
- MAX_ATTEMPTS = 10 (configurable)
- Each attempt creates immutable AttemptRecord: attempt_number, bundle_sha256, validation_report, logs, timestamp
- Failure fingerprint: hash of (error_types + failing_test_names + fix_hint_categories)
- Stop early if same fingerprint seen twice consecutively (thrash detection)
- Classify failures: retryable (test_failure, schema_mismatch) vs terminal (policy_violation, security_block)
- Terminal failures stop loop immediately with explanation

Audit trail:
- BuildAuditLog: job_id, all AttemptRecords, final_status, total_duration

Add integration tests:
- Adapter that fails then succeeds within 10 attempts
- Adapter with repeated identical failure stops early
- MAX_ATTEMPTS reached produces structured failure report
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/integration/self_evolution/test_repair_loop_max_10.py tests/integration/self_evolution/test_repeated_failure_fingerprint.py -v --tb=short`
  </verify>
  <done>
Repair loop is bounded, fingerprint-aware, and produces immutable per-attempt audit records. Terminal failures stop immediately.
  </done>
</task>

<task type="auto">
  <name>Task 3: Install attestation guard</name>
  <files>tools/builtin/module_installer.py, orchestrator/orchestrator_service.py, tests/integration/install/test_validated_only_guard.py</files>
  <action>
Harden module installer:

Pre-install checks:
- Validation status must be VALIDATED (not FAILED, ERROR, or PENDING)
- bundle_sha256 in attestation must match the actual bundle being installed
- Attestation must reference the most recent validation report

Rejection behavior:
- Non-validated attempt: reject with "validation required" error
- Hash mismatch: reject with "artifact integrity failure" error
- Both cases: log rejection in audit trail

Wire into orchestrator:
- build_module -> validate_module -> install_module flow is the only install path
- No direct install_module without prior validation in same session

Add integration tests:
- Validated bundle installs successfully
- Non-validated bundle is rejected
- Tampered bundle (hash mismatch) is rejected
- Install success creates audit record
  </action>
  <verify>
Run: `cd /Users/sertanavdan/Documents/Software/AI/gRPC_llm && python -m pytest tests/integration/install/test_validated_only_guard.py -v --tb=short`
  </verify>
  <done>
Install is impossible unless validation status is VALIDATED and attestation matches bundle_sha256. Full audit trail for all install attempts (success and rejection).
  </done>
</task>

</tasks>

<verification>
- Builder produces scaffold -> implement -> tests stages deterministically
- Repair loop converges or exits within 10 attempts
- Repeated failure fingerprint triggers early stop
- Terminal failures (policy/security) stop immediately without repair attempt
- Install guard blocks non-validated bundles
- Hash mismatch between attestation and bundle blocks install
- Every attempt is immutable and auditable
</verification>

<success_criteria>
- REQ-013: bounded self-repair loop, NL intent to installed module end-to-end
- REQ-016: validation attestation + immutable artifacts + validated-only install
- A deliberately failing adapter can be repaired into VALIDATED within <=10 attempts
- Installer guard blocks any non-validated attempt
</success_criteria>

<output>
After completion, create `.planning/phases/03-self-evolution-engine/03-04-SUMMARY.md`
</output>
