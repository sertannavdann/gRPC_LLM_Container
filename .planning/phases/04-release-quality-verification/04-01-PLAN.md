---
phase: 04-release-quality-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/billing/otc_reward.py
  - shared/billing/otc_policy_store.py
  - tests/unit/test_otc_reward.py
  - tests/unit/test_otc_policy_store.py
autonomous: true

must_haves:
  truths:
    - "OTC reward function computes correct r_tool peaking at m==n"
    - "OTC policy store persists intent_classes, module_sets, policy_checkpoints, trajectory_log, reward_events in SQLite"
    - "Trajectory logging captures tool_calls, run_units, latency_ms, success per request"
    - "Reward scoring separates observation (trajectory_log) from evaluation (reward_events)"
  artifacts:
    - path: "shared/billing/otc_reward.py"
      provides: "OTC-GRPO reward function + composite reward computation"
      exports: ["OTCRewardConfig", "otc_tool_reward", "compute_composite_reward"]
    - path: "shared/billing/otc_policy_store.py"
      provides: "SQLite-backed OTC policy checkpoint and trajectory storage"
      exports: ["OTCPolicyStore"]
    - path: "tests/unit/test_otc_reward.py"
      provides: "Unit tests for OTC reward function"
      min_lines: 60
    - path: "tests/unit/test_otc_policy_store.py"
      provides: "Unit tests for OTC policy store CRUD"
      min_lines: 80
  key_links:
    - from: "shared/billing/otc_reward.py"
      to: "shared/billing/otc_policy_store.py"
      via: "reward_events columns map to compute_composite_reward output keys"
      pattern: "r_correctness|r_tool|r_cost|r_composite"
    - from: "shared/billing/otc_policy_store.py"
      to: "shared/billing/usage_store.py"
      via: "same WAL-mode SQLite append-only pattern"
      pattern: "PRAGMA journal_mode=WAL"
---

<objective>
Create the OTC (Optimal Tool Calls) policy storage layer and reward function, bridging Phase 2 run-unit metering to the tool-call optimization signal.

Purpose: Establishes the data foundation for tool-call efficiency tracking — the orchestrator will eventually learn the optimal number of tool calls per (intent, module_set) pair. This is policy checkpoint storage, not transformer weight training.

Output: `shared/billing/otc_reward.py`, `shared/billing/otc_policy_store.py`, and their unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@shared/billing/usage_store.py
@orchestrator/rl/reward.py
@nexus_otc_policy_schema.sql
@otc_reward.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: OTC Reward Function + Policy Store</name>
  <files>shared/billing/otc_reward.py, shared/billing/otc_policy_store.py</files>
  <action>
    **shared/billing/otc_reward.py** — Relocate and adapt from root `otc_reward.py`:
    - Move the existing `OTCRewardConfig`, `otc_tool_reward()`, `compute_composite_reward()` into `shared/billing/otc_reward.py`
    - Remove the `if __name__ == "__main__"` block (tests cover validation)
    - Add proper module docstring referencing Phase 2 metering bridge
    - Add type hints for return dict (TypedDict or explicit annotation)
    - Keep zero external dependencies (stdlib `math` + `dataclasses` only)
    - Delete the root `otc_reward.py` after relocation
    - Do NOT touch `orchestrator/rl/reward.py` — that's the Agent0 training consumer (Phase 6+)

    **shared/billing/otc_policy_store.py** — Implement from `nexus_otc_policy_schema.sql`:
    - Class `OTCPolicyStore` following the `UsageStore` pattern exactly:
      - `__init__(self, db_path: str = "data/otc_policy.db")`
      - `_connect()` with WAL mode + busy_timeout=10000
      - `_init_db()` creates all 5 tables + 4 indexes from the schema
    - CRUD methods:
      - `upsert_intent_class(intent_hash: str, canonical_label: str) -> int` — returns id, increments example_count on conflict
      - `upsert_module_set(set_hash: str, module_ids: list[str], cardinality: int) -> int` — returns id
      - `upsert_policy_checkpoint(intent_class_id: int, module_set_id: int, optimal_n: float, arm_weights: bytes, confidence: float, sample_count: int, orchestrator_version: str, smooth_c: float = 2.0) -> int`
      - `log_trajectory(intent_class_id: int, module_set_id: int, tool_calls: int, run_units: float, latency_ms: int, success: bool, context_blob: bytes | None = None) -> int` — returns trajectory id
      - `score_trajectory(trajectory_id: int, r_correctness: float, r_tool: float, r_cost: float, r_composite: float, scorer_version: str) -> int` — inserts reward_event, updates trajectory_log.reward
    - Query methods:
      - `lookup_policy(intent_class_id: int, module_set_id: int) -> dict | None` — returns checkpoint or None
      - `get_trajectories(intent_class_id: int | None = None, module_set_id: int | None = None, limit: int = 100) -> list[dict]`
    - Use `datetime.now(timezone.utc).isoformat()` for timestamps (no deprecated utcnow)
    - All methods use context manager `with self._connect() as conn:`
    - Module-level logger: `logger = logging.getLogger(__name__)`
  </action>
  <verify>
    `python -c "from shared.billing.otc_reward import OTCRewardConfig, otc_tool_reward, compute_composite_reward; print('imports ok')"` succeeds.
    `python -c "from shared.billing.otc_policy_store import OTCPolicyStore; print('imports ok')"` succeeds.
    Root `otc_reward.py` no longer exists.
  </verify>
  <done>
    `shared/billing/otc_reward.py` exports OTCRewardConfig + otc_tool_reward + compute_composite_reward.
    `shared/billing/otc_policy_store.py` exports OTCPolicyStore with all 5 tables created on init, CRUD for all entities, WAL mode enabled.
    Root `otc_reward.py` deleted.
  </done>
</task>

<task type="auto">
  <name>Task 2: OTC Unit Tests</name>
  <files>tests/unit/test_otc_reward.py, tests/unit/test_otc_policy_store.py</files>
  <action>
    **tests/unit/test_otc_reward.py**:
    - Test `otc_tool_reward(m, n)` property: peak at m==n returns ~1.0
    - Test symmetry: reward(m=1, n=3) < reward(m=3, n=3) (undershoot penalized)
    - Test overshoot: reward(m=5, n=3) < reward(m=3, n=3) (overshoot penalized)
    - Test edge cases: m=0,n=0 returns 1.0; n=0,m>0 returns cosine decay
    - Test `compute_composite_reward`: success=True with m=n → r_composite near alpha
    - Test `compute_composite_reward`: success=False → r_composite negative (cost penalty only)
    - Test `compute_composite_reward`: run_units normalization caps at 5x baseline
    - Test `OTCRewardConfig` frozen dataclass (cannot mutate)

    **tests/unit/test_otc_policy_store.py** (use tmp_path fixture for SQLite):
    - Test `_init_db()` creates all 5 tables (query sqlite_master)
    - Test `upsert_intent_class` creates and returns id; re-upsert increments example_count
    - Test `upsert_module_set` creates and returns id; re-upsert is idempotent
    - Test `upsert_policy_checkpoint` creates; re-upsert updates optimal_n
    - Test `log_trajectory` returns incrementing ids; verify fields stored correctly
    - Test `score_trajectory` inserts reward_event and updates trajectory_log.reward
    - Test `lookup_policy` returns dict for existing pair, None for missing
    - Test `get_trajectories` with filters and limit
    - All tests use `tmp_path / "test_otc.db"` (no disk pollution)
    - Import store directly: `from shared.billing.otc_policy_store import OTCPolicyStore`
  </action>
  <verify>
    `python -m pytest tests/unit/test_otc_reward.py tests/unit/test_otc_policy_store.py -v --tb=short` — all pass.
  </verify>
  <done>
    OTC reward tests cover peak, undershoot, overshoot, edge cases, composite success/failure.
    OTC policy store tests cover all CRUD operations, upsert semantics, query filters.
    Zero test failures.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/unit/test_otc_reward.py tests/unit/test_otc_policy_store.py -v` passes
- `python -c "from shared.billing.otc_reward import compute_composite_reward"` imports cleanly
- `python -c "from shared.billing.otc_policy_store import OTCPolicyStore"` imports cleanly
- Root `otc_reward.py` deleted
- No changes to `orchestrator/rl/` (future consumer)
</verification>

<success_criteria>
- OTC reward function relocated to `shared/billing/` with zero dependency on numpy/torch
- Policy store follows UsageStore WAL-mode SQLite pattern exactly
- All 5 OTC tables created on store initialization
- 15+ unit tests covering reward math + store CRUD
- Root `otc_reward.py` and `nexus_otc_policy_schema.sql` removed (code is now in shared/billing/)
</success_criteria>

<output>
After completion, create `.planning/phases/04-release-quality-verification/04-01-SUMMARY.md`
</output>
