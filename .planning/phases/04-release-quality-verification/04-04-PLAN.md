---
phase: 04-release-quality-verification
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - ui_service/src/lib/provider-lock/base.ts
  - ui_service/src/lib/provider-lock/providers.ts
  - ui_service/src/app/api/settings/route.ts
  - ui_service/src/app/api/settings/connection-test/route.ts
  - ui_service/src/app/settings/page.tsx
  - ui_service/src/components/settings/SettingsPanel.tsx
  - tests/integration/ui/test_settings_provider_lock.py
autonomous: true

must_haves:
  truths:
    - "Providers missing required connection prerequisites are shown as locked"
    - "Unlock action calls an API endpoint, validates connection, and updates lock state"
    - "Connection test output (success/failure + message) is visible in Settings UI"
    - "Provider lock/unlock logic is implemented via a reusable base class with provider-specific subclasses"
    - "Same lock logic can be reused by dashboard APIs without duplicating validation rules"
  artifacts:
    - path: "ui_service/src/lib/provider-lock/base.ts"
      provides: "Base class contract for provider requirement checking and connection testing"
      exports: ["ProviderUnlockBase"]
    - path: "ui_service/src/lib/provider-lock/providers.ts"
      provides: "Concrete unlock classes per provider (nvidia/openai/anthropic/perplexity/local)"
      exports: ["NvidiaUnlock", "OpenAIUnlock", "AnthropicUnlock", "PerplexityUnlock", "LocalUnlock", "getProviderUnlockHandler"]
    - path: "ui_service/src/app/api/settings/connection-test/route.ts"
      provides: "Server-side provider connection test endpoint consumed by unlock button"
      exports: ["POST"]
    - path: "ui_service/src/app/settings/page.tsx"
      provides: "Locked provider UX + unlock button + test output rendering"
      min_lines: 80
    - path: "tests/integration/ui/test_settings_provider_lock.py"
      provides: "Integration tests for lock metadata and connection-test endpoint"
      min_lines: 80
  key_links:
    - from: "ui_service/src/app/settings/page.tsx"
      to: "/api/settings/connection-test"
      via: "Unlock button onClick performs POST and updates provider lock state"
      pattern: "fetch\('/api/settings/connection-test'"
    - from: "ui_service/src/app/api/settings/route.ts"
      to: "ui_service/src/lib/provider-lock/providers.ts"
      via: "Builds provider lock metadata from shared base/subclass logic"
      pattern: "getProviderUnlockHandler|isLocked|missingRequirements"
    - from: "ui_service/src/app/api/settings/connection-test/route.ts"
      to: "ui_service/src/lib/provider-lock/base.ts"
      via: "Invokes subclass connection test implementation"
      pattern: "extends ProviderUnlockBase|testConnection"
---

<objective>
Add release-quality provider lock/unlock behavior in Settings: only providers lacking full connection requirements are locked, unlock is API-driven, connection test results are shown to users, and lock logic is abstracted into a base class for reuse by dashboard APIs.

Purpose: Fixes current provider selection UX bugs while establishing a reusable validation architecture (base + subclass pattern) for future dashboard integration.

Output: Reusable provider unlock class hierarchy, settings API lock metadata + connection test endpoint, UI lock/unlock flow, and integration tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@ui_service/src/app/api/settings/route.ts
@ui_service/src/app/settings/page.tsx
@ui_service/src/components/settings/SettingsPanel.tsx
@shared/providers/config.py
@config/routing_config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement reusable provider lock/unlock base class architecture</name>
  <files>ui_service/src/lib/provider-lock/base.ts, ui_service/src/lib/provider-lock/providers.ts, ui_service/src/app/api/settings/route.ts, ui_service/src/app/api/settings/connection-test/route.ts</files>
  <action>
    Create a reusable lock/unlock module using class inheritance (user decision is locked):
    - Add `ProviderUnlockBase` abstract class in `base.ts` with methods:
      - `getRequiredFields(envConfig): string[]` (returns missing requirements)
      - `isLocked(envConfig): boolean` (derived from missing requirements)
      - `testConnection(payload): Promise<{ success: boolean; message: string; details?: Record<string, unknown> }>`
      - `public toStatus(envConfig)` helper returning `{ locked, missingRequirements, canTest }`
    - Add concrete subclasses in `providers.ts` (local/nvidia/openai/anthropic/perplexity):
      - Local is always unlocked and test is a no-op health check.
      - Cloud providers lock only when required connection prerequisites are missing (API key and base URL when applicable).
      - Connection tests call provider-relevant probes (NVIDIA/OpenAI-compatible path via lightweight chat probe; fail fast with actionable error message).
    - Add a factory `getProviderUnlockHandler(providerName)` so dashboard APIs can reuse the same class map later.

    Wire settings APIs to the class hierarchy:
    - Extend `GET /api/settings` response with per-provider lock metadata (e.g., `providerLocks[provider] = { locked, missingRequirements, canTest }`).
    - Add `POST /api/settings/connection-test` endpoint that accepts provider + optional key overrides and returns standardized test output from the class instance.
    - Keep existing provider selection persistence behavior unchanged; lock metadata augments it.

    Constraints:
    - Do not hardcode new colors/theme primitives.
    - Keep logic centralized in the class hierarchy; no duplicate lock rules in routes.
  </action>
  <verify>
    `python3 -c "import requests; r=requests.get('http://localhost:5001/api/settings', timeout=15); j=r.json(); print(r.status_code, 'providerLocks' in j)"` returns `200 True`.
    `python3 -c "import requests; r=requests.post('http://localhost:5001/api/settings/connection-test', json={'provider':'nvidia'}, timeout=20); print(r.status_code); print(r.json().get('success') is not None)"` succeeds with structured JSON.
  </verify>
  <done>
    Provider lock state derives exclusively from base/subclass unlock classes.
    Settings API exposes lock metadata for each provider.
    Connection-test endpoint returns uniform `{success,message,details}` output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix Settings UI lock/unlock behavior and show connection test output</name>
  <files>ui_service/src/app/settings/page.tsx, ui_service/src/components/settings/SettingsPanel.tsx</files>
  <action>
    Update Settings UI to consume lock metadata and expose unlock workflow:
    - Render lock state per provider card using existing iconography and tokens.
    - Providers marked locked cannot be selected for save/apply until unlocked.
    - Add "Unlock" button on locked providers; clicking triggers `/api/settings/connection-test`.
    - Show connection-test output inline to user (success/failure message + concise details).
    - On successful test, update provider lock state in component state without full page reload.
    - Preserve current provider/model persistence behavior and keep selected model stable when valid.

    UX scope (minimal):
    - No new pages/modals.
    - No new themes/animations.
    - Use existing status components/messages already in settings page.
  </action>
  <verify>
    `docker compose logs ui_service --tail=120` shows no unhandled settings route errors while testing lock/unlock.
    Manual interaction: locked provider shows Unlock button, test result appears, successful unlock enables selection and save.
  </verify>
  <done>
    Locked providers are visually and functionally gated.
    Unlock flow is API-driven and surfaces result to the user.
    Selection/save is blocked for locked providers and enabled after unlock.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for provider lock metadata and connection test API</name>
  <files>tests/integration/ui/test_settings_provider_lock.py</files>
  <action>
    Add release-quality integration tests targeting UI settings APIs:
    - Test `GET /api/settings` includes `providerLocks` for all providers and each entry has `locked` + `missingRequirements` fields.
    - Test cloud providers become locked when required env values are absent.
    - Test providers with complete requirements are unlocked.
    - Test `POST /api/settings/connection-test` returns standardized payload shape and non-500 responses for valid providers.
    - Test invalid provider input returns 400 with clear error.
    - Include one happy-path test with mocked/stubbed reachable provider probe (or local provider check) to validate success output.

    Testing approach:
    - Keep tests runnable with existing pytest stack.
    - Skip gracefully with explicit reason if UI service is not reachable in local environment.
  </action>
  <verify>
    `python -m pytest tests/integration/ui/test_settings_provider_lock.py -v --tb=short` passes.
  </verify>
  <done>
    Lock metadata and connection-test endpoints are covered by integration tests.
    Failures produce actionable messages for requirement gaps.
  </done>
</task>


</tasks>

<verification>
- `python -m pytest tests/integration/ui/test_settings_provider_lock.py -v` passes.
- `GET /api/settings` includes lock metadata per provider.
- `POST /api/settings/connection-test` returns standardized output and actionable failures.
- Manual UI verification confirms lock gating + unlock + persisted selection flow.
</verification>

<success_criteria>
- Requirement-based lock logic applies only to providers missing full connection prerequisites.
- Unlock logic is implemented via base class + subclasses and is reusable for dashboard APIs.
- Unlock button triggers API connection test and shows output to user.
- Provider selection persistence remains stable after lock/unlock interactions.
</success_criteria>

<output>
After completion, create `.planning/phases/04-release-quality-verification/04-04-SUMMARY.md`
</output>
