---
phase: 05-refactoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/modules/security_policy.py
  - shared/modules/static_analysis.py
  - shared/modules/identifiers.py
  - shared/modules/hashing.py
  - shared/modules/validation_types.py
  - shared/modules/contracts.py
  - shared/modules/artifacts.py
  - sandbox_service/policy.py
  - sandbox_service/runner.py
  - tools/builtin/module_builder.py
  - tools/builtin/module_validator.py
  - tools/builtin/module_installer.py
  - tests/unit/test_shared_modules_dedup.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FORBIDDEN_IMPORTS is defined in exactly one file and imported everywhere else"
    - "StaticImportChecker exists in exactly one file with a single implementation"
    - "module_id parsing uses a single shared function across all 6 call sites"
    - "SHA-256 hashing uses shared functions — no inline hashlib.sha256 in builder/installer/artifacts"
    - "ValidationReport shape is unified between validator and sandbox runner"
    - "No dead code remains: unused verify_bundle_hash removed, duplicate null checks removed"
  artifacts:
    - path: "shared/modules/security_policy.py"
      provides: "Single source of truth for FORBIDDEN_IMPORTS set and import policy constants"
      exports: ["FORBIDDEN_IMPORTS", "SAFE_BUILTINS"]
      min_lines: 30
    - path: "shared/modules/static_analysis.py"
      provides: "Single StaticImportChecker implementation"
      exports: ["StaticImportChecker", "check_imports"]
      min_lines: 50
    - path: "shared/modules/identifiers.py"
      provides: "Module ID parsing and validation"
      exports: ["ModuleIdentifier", "parse_module_id", "validate_module_id"]
      min_lines: 40
    - path: "shared/modules/hashing.py"
      provides: "SHA-256 content and bundle hashing"
      exports: ["compute_sha256", "compute_bundle_hash"]
      min_lines: 25
    - path: "shared/modules/validation_types.py"
      provides: "Unified ValidationResult model used by validator and sandbox"
      exports: ["ValidationResult", "ValidationSeverity", "ValidationEntry"]
      min_lines: 40
    - path: "tests/unit/test_shared_modules_dedup.py"
      provides: "Tests for all extracted shared modules"
      min_lines: 120
  key_links:
    - from: "shared/modules/contracts.py"
      to: "shared/modules/security_policy.py"
      via: "imports FORBIDDEN_IMPORTS instead of defining it"
      pattern: "from shared\\.modules\\.security_policy import"
    - from: "sandbox_service/policy.py"
      to: "shared/modules/security_policy.py"
      via: "imports FORBIDDEN_IMPORTS instead of defining it"
      pattern: "from shared\\.modules\\.security_policy import"
    - from: "sandbox_service/runner.py"
      to: "shared/modules/static_analysis.py"
      via: "imports StaticImportChecker instead of defining it"
      pattern: "from shared\\.modules\\.static_analysis import"
    - from: "tools/builtin/module_builder.py"
      to: "shared/modules/identifiers.py"
      via: "imports parse_module_id instead of inline parsing"
      pattern: "from shared\\.modules\\.identifiers import"
    - from: "tools/builtin/module_installer.py"
      to: "shared/modules/hashing.py"
      via: "imports compute_sha256 instead of inline hashing"
      pattern: "from shared\\.modules\\.hashing import"
---

<objective>
Consolidate the six areas of code duplication across the self-evolution module system into single-source-of-truth shared modules.

Purpose: Phase 3 built the self-evolution engine across 7+ files. During that build, several patterns were copy-pasted rather than extracted: FORBIDDEN_IMPORTS (2 definitions), AST import checker (2 implementations), module_id parsing (6 call sites with inline logic), SHA-256 hashing (3 implementations), and divergent validation report shapes. This plan extracts each into a canonical shared module, updates all consumers, and removes dead code.

Output: 5 new shared modules in `shared/modules/`, updated consumers across builder/validator/installer/contracts/sandbox, comprehensive tests, zero regressions in `make test-self-evolution`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-minimal.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-refactoring/05-CONTEXT.md

@shared/modules/contracts.py
@shared/modules/artifacts.py
@sandbox_service/policy.py
@sandbox_service/runner.py
@tools/builtin/module_builder.py
@tools/builtin/module_validator.py
@tools/builtin/module_installer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract FORBIDDEN_IMPORTS + import policy</name>
  <files>shared/modules/security_policy.py, shared/modules/contracts.py, sandbox_service/policy.py</files>
  <action>
    Create `shared/modules/security_policy.py`:
    - Move the `FORBIDDEN_IMPORTS` set from `shared/modules/contracts.py` here as the single definition
    - Include `SAFE_BUILTINS` if it exists in either source
    - Add docstring referencing EDMO doc T2 (compensation scope): "Policy violations are terminal failures — no retry"

    Update `shared/modules/contracts.py`:
    - Remove the `FORBIDDEN_IMPORTS` definition
    - Add `from shared.modules.security_policy import FORBIDDEN_IMPORTS`
    - Verify all existing references still resolve

    Update `sandbox_service/policy.py`:
    - Remove its duplicate `FORBIDDEN_IMPORTS` definition
    - Add `from shared.modules.security_policy import FORBIDDEN_IMPORTS`
    - Keep the sandbox-specific `ALLOWED_IMPORTS` allowlist in place — it references FORBIDDEN_IMPORTS for exclusion
  </action>
  <verify>
    `grep -rn "FORBIDDEN_IMPORTS\s*=" --include="*.py" | wc -l` returns exactly 1 (the definition in security_policy.py).
    `python -c "from shared.modules.security_policy import FORBIDDEN_IMPORTS; print(len(FORBIDDEN_IMPORTS))"` succeeds.
    `python -c "from shared.modules.contracts import FORBIDDEN_IMPORTS"` succeeds (re-export or direct import).
    `python -c "from sandbox_service.policy import SandboxPolicy"` succeeds.
  </verify>
  <done>
    FORBIDDEN_IMPORTS defined in exactly one file. Both contracts.py and policy.py import from it.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract StaticImportChecker</name>
  <files>shared/modules/static_analysis.py, shared/modules/contracts.py, sandbox_service/runner.py</files>
  <action>
    Create `shared/modules/static_analysis.py`:
    - Move the `StaticImportChecker` class (AST-based import analysis) from whichever file has the more complete implementation
    - Add a convenience function `check_imports(source: str, forbidden: set[str]) -> list[str]` that returns list of violation descriptions
    - Import `FORBIDDEN_IMPORTS` from `shared.modules.security_policy` as default forbidden set

    Update `shared/modules/contracts.py`:
    - Remove its `StaticImportChecker` class if present
    - Add import from `shared.modules.static_analysis`

    Update `sandbox_service/runner.py`:
    - Remove its `StaticImportChecker` class
    - Add `from shared.modules.static_analysis import StaticImportChecker`
    - Verify the runner's call sites still work with the unified implementation
  </action>
  <verify>
    `grep -rn "class StaticImportChecker" --include="*.py" | wc -l` returns exactly 1.
    `python -c "from shared.modules.static_analysis import StaticImportChecker, check_imports; print('ok')"` succeeds.
  </verify>
  <done>
    StaticImportChecker exists in exactly one file. Both contracts.py and runner.py import from it.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extract module_id parsing</name>
  <files>shared/modules/identifiers.py, tools/builtin/module_builder.py, tools/builtin/module_validator.py, tools/builtin/module_installer.py, shared/modules/contracts.py, shared/modules/artifacts.py</files>
  <action>
    Create `shared/modules/identifiers.py`:
    - `ModuleIdentifier` dataclass: `category: str`, `platform: str`, `raw: str`
    - `parse_module_id(raw: str) -> ModuleIdentifier` — splits on "/" or "_", validates format, raises ValueError on malformed input
    - `validate_module_id(raw: str) -> bool` — returns True/False without raising

    Search all 6 files for inline module_id parsing patterns (split on "/", strip, format checks) and replace with `parse_module_id()` or `validate_module_id()` calls.

    Common patterns to find and replace:
    - `module_id.split("/")`
    - `category, platform = ...split...`
    - Inline format validation checks
  </action>
  <verify>
    `grep -rn "module_id\.split" --include="*.py" tools/ shared/modules/ | wc -l` returns 0 (all replaced with parse_module_id).
    `python -c "from shared.modules.identifiers import parse_module_id; r = parse_module_id('weather/openweather'); print(r.category, r.platform)"` outputs "weather openweather".
  </verify>
  <done>
    All 6 call sites use parse_module_id/validate_module_id. No inline module_id splitting remains.
  </done>
</task>

<task type="auto">
  <name>Task 4: Extract SHA-256 hashing</name>
  <files>shared/modules/hashing.py, shared/modules/artifacts.py, tools/builtin/module_installer.py, tools/builtin/module_builder.py</files>
  <action>
    Create `shared/modules/hashing.py`:
    - `compute_sha256(content: bytes) -> str` — returns hex digest
    - `compute_bundle_hash(files: dict[str, bytes]) -> str` — deterministic hash of sorted file contents (same algorithm as artifacts.py)

    Update `shared/modules/artifacts.py`:
    - Remove inline SHA-256 hashing
    - Import from `shared.modules.hashing`

    Update `tools/builtin/module_installer.py`:
    - Remove inline `hashlib.sha256(...)` calls
    - Import from `shared.modules.hashing`
    - Remove `verify_bundle_hash` if it duplicates `compute_bundle_hash` + comparison

    Update `tools/builtin/module_builder.py`:
    - Remove inline SHA-256 calls
    - Import from `shared.modules.hashing`
  </action>
  <verify>
    `grep -rn "hashlib\.sha256" --include="*.py" tools/ shared/modules/ | grep -v hashing.py | grep -v test_ | wc -l` returns 0.
    `python -c "from shared.modules.hashing import compute_sha256, compute_bundle_hash; print(compute_sha256(b'test'))"` succeeds.
  </verify>
  <done>
    All SHA-256 operations route through shared/modules/hashing.py. No inline hashlib.sha256 in builder/installer/artifacts.
  </done>
</task>

<task type="auto">
  <name>Task 5: Unify validation report shape</name>
  <files>shared/modules/validation_types.py, tools/builtin/module_validator.py, sandbox_service/runner.py</files>
  <action>
    Create `shared/modules/validation_types.py`:
    - `ValidationSeverity` enum: ERROR, WARNING, INFO
    - `ValidationEntry` dataclass: `severity: ValidationSeverity`, `category: str`, `message: str`, `file: str | None`, `line: int | None`, `fix_hint: str | None`
    - `ValidationResult` dataclass: `passed: bool`, `entries: list[ValidationEntry]`, `summary: str`, `checked_at: datetime`
    - Helper: `merge_results(*results: ValidationResult) -> ValidationResult` — combines entries, passed = all passed

    Update `tools/builtin/module_validator.py`:
    - Replace its internal report structure with `ValidationResult`
    - Ensure `fix_hint` field is populated for repair-stage consumption

    Update `sandbox_service/runner.py`:
    - Replace its internal report structure with `ValidationResult`
    - Map sandbox violations to `ValidationEntry` with appropriate severity
  </action>
  <verify>
    `python -c "from shared.modules.validation_types import ValidationResult, ValidationEntry, merge_results; print('ok')"` succeeds.
    `grep -rn "class ValidationReport" --include="*.py" | wc -l` returns 0 (replaced by ValidationResult).
  </verify>
  <done>
    Unified ValidationResult used by both validator and sandbox runner. merge_results combines reports for the repair stage.
  </done>
</task>

<task type="auto">
  <name>Task 6: Dead code removal + dedup tests</name>
  <files>tools/builtin/module_installer.py, tests/unit/test_shared_modules_dedup.py</files>
  <action>
    Dead code removal:
    - Remove unused `verify_bundle_hash` from installer if it duplicates compute_bundle_hash + comparison logic
    - Remove duplicate null check in installer attestation guard (identified in research)
    - Scan for any unreferenced private functions in the 7 modified files and remove them
    - Run `grep -rn "def _" --include="*.py" tools/builtin/ shared/modules/` and verify each private function has at least one call site

    Create `tests/unit/test_shared_modules_dedup.py`:
    - Test `FORBIDDEN_IMPORTS` contains expected dangerous modules (os, subprocess, etc.)
    - Test `StaticImportChecker` detects forbidden import in sample code
    - Test `check_imports` returns violation list for code with `import os`
    - Test `parse_module_id` handles valid ("weather/openweather"), invalid ("noslash"), edge cases ("")
    - Test `validate_module_id` returns bool correctly
    - Test `compute_sha256` returns correct hex digest for known input
    - Test `compute_bundle_hash` is deterministic (same files in different order → same hash)
    - Test `ValidationResult` creation and `merge_results` logic
    - Test `ValidationEntry` severity filtering
  </action>
  <verify>
    `python -m pytest tests/unit/test_shared_modules_dedup.py -v --tb=short` — all pass.
    `make test-self-evolution` — zero regressions.
  </verify>
  <done>
    All dead code removed. 15+ tests for extracted shared modules pass. Full self-evolution test suite has zero regressions.
  </done>
</task>

</tasks>

<verification>
- `grep -rn "FORBIDDEN_IMPORTS\s*=" --include="*.py" | wc -l` returns exactly 1
- `grep -rn "class StaticImportChecker" --include="*.py" | wc -l` returns exactly 1
- `grep -rn "module_id\.split" --include="*.py" tools/ shared/modules/ | wc -l` returns 0
- `grep -rn "hashlib\.sha256" --include="*.py" tools/ shared/modules/ | grep -v hashing.py | grep -v test_ | wc -l` returns 0
- `python -m pytest tests/unit/test_shared_modules_dedup.py -v` — all pass
- `make test-self-evolution` — zero regressions
</verification>

<success_criteria>
- Six areas of code duplication consolidated into five shared modules
- All consumers updated to import from shared modules
- Dead code removed (unused functions, duplicate checks)
- 15+ regression tests for extracted modules
- `make test-self-evolution` passes with zero regressions
- No circular imports introduced
</success_criteria>

<output>
After completion, create `.planning/phases/05-refactoring/05-01-SUMMARY.md`
</output>
