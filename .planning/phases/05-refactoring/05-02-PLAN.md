---
phase: 05-refactoring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - agents/souls/builder.soul.md
  - agents/souls/tester.soul.md
  - agents/souls/monitor.soul.md
  - shared/agents/__init__.py
  - shared/agents/prompt_composer.py
  - shared/agents/confidence.py
  - tools/builtin/module_builder.py
  - shared/providers/llm_gateway.py
  - tests/unit/test_prompt_composer.py
  - tests/unit/test_confidence_scorer.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "builder.soul.md, tester.soul.md, monitor.soul.md exist as version-controlled files"
    - "compose() function loads soul.md and interpolates stage context, intent, and repair hints"
    - "module_builder.py calls compose() before every gateway.generate() call"
    - "LLM gateway uses exponential backoff with jitter on transient failures (429, 503)"
    - "Blueprint2Code confidence scorer rejects scaffolds with confidence < 0.6"
  artifacts:
    - path: "agents/souls/builder.soul.md"
      provides: "Builder agent identity — mission, scope, capabilities, guardrails, output contract, acceptable patterns, stop conditions"
      min_lines: 40
    - path: "agents/souls/tester.soul.md"
      provides: "Tester agent identity — adversarial validation, test taxonomy (Class A + B), quality gates, repair hint protocol"
      min_lines: 40
    - path: "agents/souls/monitor.soul.md"
      provides: "Monitor agent identity — stage fidelity validation, gap detection, proceed/revise recommendations"
      min_lines: 30
    - path: "shared/agents/prompt_composer.py"
      provides: "Auto-prompt composition function that merges soul.md + stage context + intent + repair hints"
      exports: ["compose", "StageContext", "load_soul"]
      min_lines: 60
    - path: "shared/agents/confidence.py"
      provides: "Blueprint2Code confidence scorer for scaffold quality gating"
      exports: ["Blueprint2CodeScorer", "ScaffoldScore"]
      min_lines: 40
    - path: "tests/unit/test_prompt_composer.py"
      provides: "Tests for compose() function across all 4 stages"
      min_lines: 80
    - path: "tests/unit/test_confidence_scorer.py"
      provides: "Tests for scaffold confidence scoring and threshold gating"
      min_lines: 50
  key_links:
    - from: "shared/agents/prompt_composer.py"
      to: "agents/souls/builder.soul.md"
      via: "load_soul reads the soul.md file at runtime"
      pattern: "load_soul|soul\\.md|builder\\.soul"
    - from: "tools/builtin/module_builder.py"
      to: "shared/agents/prompt_composer.py"
      via: "calls compose() before each gateway.generate()"
      pattern: "from shared\\.agents\\.prompt_composer import"
    - from: "tools/builtin/module_builder.py"
      to: "shared/agents/confidence.py"
      via: "scores scaffold output before proceeding to implement stage"
      pattern: "from shared\\.agents\\.confidence import"
    - from: "shared/providers/llm_gateway.py"
      to: "shared/agents/prompt_composer.py"
      via: "gateway receives composed prompts from builder"
      pattern: "backoff|jitter|retry"
---

<objective>
Create soul.md agent identity files and wire auto-prompt composition into the build pipeline, transforming the LLM Gateway from a stateless endpoint into a structured multi-agent system.

Purpose: The build pipeline currently sends raw prompts to the LLM Gateway without structured agent identity. Academic research (Agentic Builder-Tester Pattern §3.2, §4.1) shows that role-based prompting via soul.md files dramatically improves code generation reliability. The planner-coder gap (75.3% of multi-agent failures per §2.3) is mitigated by Blueprint2Code confidence scoring that rejects low-quality scaffolds before they propagate errors downstream. Bounded retry with jitter (EDMO doc T4) prevents retry storms on LLM provider transient failures.

Output: 3 soul.md files, `compose()` function, confidence scorer, bounded retry in gateway, comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-minimal.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-refactoring/05-CONTEXT.md

@tools/builtin/module_builder.py
@tools/builtin/module_validator.py
@shared/providers/llm_gateway.py
@shared/modules/contracts.py

@Agentic Builder-Tester Pattern for NEXUS.md
@Event-Driven Microservice Orchestration Principles.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create soul.md agent identity files</name>
  <files>agents/souls/builder.soul.md, agents/souls/tester.soul.md, agents/souls/monitor.soul.md</files>
  <action>
    Create `agents/souls/` directory with three soul.md files.

    **builder.soul.md** — based on Agentic doc §5.1:
    ```
    Mission: Transform NL module intent into schema-valid patch payloads
    Role: Senior module engineer for NEXUS platform
    Scope: Only generate files within allowlisted paths, only use approved imports
    Capabilities: scaffold | implement | repair stages
    Output Contract: structured JSON matching BuilderGenerationContract
    Acceptable Patterns: REST client via approved HTTP lib, OAuth via credential manager,
      pagination with loop guards, error classification (AUTH_INVALID|AUTH_EXPIRED|TRANSIENT|FATAL)
    Guardrails: No dynamic imports/exec/eval/subprocess, no network outside integration allowlist
    Stop Conditions: Schema validation failure → reject, policy violation → reject,
      3 consecutive identical fingerprints → escalate
    ```

    **tester.soul.md** — based on Agentic doc §5.2:
    ```
    Mission: Validate generated modules through contract + feature tests
    Role: QA engineer — adversarial, coverage-maximizing, deterministic
    Scope: Generate tests only, never modify module source
    Test Taxonomy: Class A (contract: registration, interface, schema, error, config)
      + Class B (feature: connectivity, auth, data mapping, charts, orchestrator, dev-mode)
    Quality Gate: Hard (A1-A5 + required B-suite) / Soft (coverage ≥80%, B5/B6)
    Repair Hints: failed_test_id, failure_category, suggested_fix, confidence
    Stop: All hard gates pass → VALIDATED, failure after max attempts → FAILED with report
    ```

    **monitor.soul.md** — based on Agentic doc §9:
    ```
    Mission: Validate fidelity between pipeline stages
    Role: Observer — never mutates, only evaluates
    Checks: scaffold→implement file coverage, implement→test capability coverage,
      assumption carry-through, error path coverage
    Output: fidelity_score (0-100), gaps[], recommendation (PROCEED|REVISE_PLAN|REVISE_IMPLEMENTATION)
    ```
  </action>
  <verify>
    `ls agents/souls/*.soul.md | wc -l` returns 3.
    Each file contains "Mission", "Scope", and "Guardrails" or "Stop Conditions" sections.
  </verify>
  <done>
    Three version-controlled soul.md files created with structured identity definitions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement compose() auto-prompt function</name>
  <files>shared/agents/__init__.py, shared/agents/prompt_composer.py</files>
  <action>
    Create `shared/agents/__init__.py` (empty or minimal).

    Create `shared/agents/prompt_composer.py`:

    **StageContext** dataclass:
    - `stage: str` — "scaffold" | "implement" | "test" | "repair"
    - `attempt: int` — current attempt number
    - `intent: str` — the NL build request
    - `constraints: dict | None` — user constraints from build request
    - `prior_artifacts: dict | None` — latest artifacts from artifact store
    - `repair_hints: list[str] | None` — validator fix hints (repair stage only)
    - `policy_profile: str | None` — current policy profile name
    - `manifest_snapshot: dict | None` — current manifest state

    **load_soul(agent_role: str) -> str**:
    - Reads `agents/souls/{agent_role}.soul.md`
    - Returns file content as string
    - Raises FileNotFoundError if soul file missing
    - Caches loaded souls in module-level dict to avoid repeated disk reads

    **compose(system: str, context: StageContext, output_schema: dict | None = None) -> str**:
    - Takes the loaded soul.md content as `system`
    - Appends structured stage context section:
      ```
      ## Current Stage: {context.stage} (Attempt {context.attempt})
      ## Intent: {context.intent}
      ## Constraints: {json.dumps(context.constraints)}
      ```
    - If repair stage: appends repair hints section with numbered list
    - If output_schema: appends "## Required Output Schema" section
    - Returns the composed prompt string

    Follow Agentic doc §6.2 auto-prompt construction pattern.
  </action>
  <verify>
    `python -c "from shared.agents.prompt_composer import compose, StageContext, load_soul; print('ok')"` succeeds.
    `python -c "from shared.agents.prompt_composer import load_soul; s = load_soul('builder'); assert 'Mission' in s"` succeeds.
  </verify>
  <done>
    compose() loads soul.md, interpolates stage context, returns composed prompt. load_soul() reads and caches soul files.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Blueprint2Code confidence scorer</name>
  <files>shared/agents/confidence.py</files>
  <action>
    Create `shared/agents/confidence.py`:

    **ScaffoldScore** dataclass:
    - `completeness: float` — 0-1, do changed_files cover all manifest capabilities?
    - `feasibility: float` — 0-1, are imported modules in the allowlist?
    - `edge_case_handling: float` — 0-1, are error paths defined?
    - `efficiency: float` — 0-1, is file count within reasonable bounds?
    - `overall: float` — weighted average of above (0-1)

    **Blueprint2CodeScorer** class:
    - `__init__(self, threshold: float = 0.6)` — configurable confidence threshold
    - `score(scaffold_output: dict, manifest: dict, policy_profile: str) -> ScaffoldScore`:
      - Completeness: check changed_files covers manifest declared capabilities
      - Feasibility: check imports against FORBIDDEN_IMPORTS (from security_policy)
      - Edge cases: check for error handling patterns (try/except, error classification)
      - Efficiency: check file_count <= expected, total_size <= limit
      - Overall: `0.3*completeness + 0.3*feasibility + 0.2*edge_case + 0.2*efficiency`
    - `passes_threshold(score: ScaffoldScore) -> bool` — returns score.overall >= self.threshold

    Reference: Agentic doc §4.3 (Blueprint2Code confidence) and §7 (five-dimension scoring).
  </action>
  <verify>
    `python -c "from shared.agents.confidence import Blueprint2CodeScorer, ScaffoldScore; print('ok')"` succeeds.
  </verify>
  <done>
    Blueprint2CodeScorer scores scaffolds on 4 dimensions. Threshold defaults to 0.6, configurable.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire compose() into build pipeline</name>
  <files>tools/builtin/module_builder.py</files>
  <action>
    Modify `tools/builtin/module_builder.py` to use auto-prompt composition:

    Import:
    ```python
    from shared.agents.prompt_composer import compose, StageContext, load_soul
    from shared.agents.confidence import Blueprint2CodeScorer
    ```

    At module level, load souls and create scorer:
    ```python
    _builder_soul = load_soul("builder")
    _scorer = Blueprint2CodeScorer(threshold=0.6)
    ```

    Before each `gateway.generate()` call in the stage pipeline:
    1. Create `StageContext` with current stage name, attempt number, intent, constraints, prior artifacts, repair hints
    2. Call `composed_prompt = compose(system=_builder_soul, context=stage_ctx)`
    3. Pass `composed_prompt` as the system prompt to `gateway.generate()`

    After scaffold stage output:
    1. Score with `_scorer.score(scaffold_output, manifest, policy_profile)`
    2. If `not _scorer.passes_threshold(score)`: regenerate with refined prompt (max 2 retries)
    3. Log scaffold confidence score for observability

    Keep the existing stage flow intact — compose() wraps existing prompts, it doesn't replace the pipeline logic.
  </action>
  <verify>
    `python -c "from tools.builtin.module_builder import build_module; print('imports ok')"` succeeds.
    Verify compose() is called in the scaffold, implement, and repair code paths via grep:
    `grep -n "compose(" tools/builtin/module_builder.py | wc -l` returns >= 3.
  </verify>
  <done>
    Build pipeline uses compose() for all LLM calls. Scaffold stage gated by confidence scorer.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add bounded retry with jitter to LLM gateway</name>
  <files>shared/providers/llm_gateway.py</files>
  <action>
    Modify `shared/providers/llm_gateway.py` to add resilient retry logic:

    Add retry function:
    ```python
    import random
    import time

    def _compute_backoff(attempt: int, base: float = 1.0, cap: float = 30.0) -> float:
        """Exponential backoff with jitter. EDMO doc T4: reduces P99 from 2600ms to 1100ms."""
        delay = min(base * (2 ** attempt), cap)
        jitter = random.uniform(0, delay * 0.5)
        return delay + jitter
    ```

    Wrap the HTTP/API call in the `generate()` method with retry logic:
    - Retry on transient errors: HTTP 429, 503, 500, connection errors, timeouts
    - Do NOT retry on: 401 (auth), 400 (bad request), 422 (validation) — fail fast
    - Max retries: 5 (configurable via `max_retries` parameter)
    - Log each retry attempt with delay and error type
    - If 429 with Retry-After header: use that value instead of computed backoff

    Per-error-class policy (EDMO doc §5.2):
    - Transient (429, 5xx, timeout): retry with backoff
    - Permanent (4xx except 429): fail immediately
    - Network (ConnectionError, etc.): retry with backoff
  </action>
  <verify>
    `grep -n "_compute_backoff\|jitter" shared/providers/llm_gateway.py | wc -l` returns >= 2.
    `python -c "from shared.providers.llm_gateway import LLMGateway; print('ok')"` succeeds.
  </verify>
  <done>
    LLM Gateway retries transient failures with exponential backoff + jitter. Permanent failures fail fast. Max 5 retries.
  </done>
</task>

<task type="auto">
  <name>Task 6: Tests for compose() and confidence scorer</name>
  <files>tests/unit/test_prompt_composer.py, tests/unit/test_confidence_scorer.py</files>
  <action>
    **tests/unit/test_prompt_composer.py**:
    - Test `load_soul("builder")` returns string containing "Mission"
    - Test `load_soul("nonexistent")` raises FileNotFoundError
    - Test `compose()` for scaffold stage includes soul content + stage name + intent
    - Test `compose()` for implement stage includes prior artifacts section
    - Test `compose()` for repair stage includes repair hints section
    - Test `compose()` for test stage includes test taxonomy reference
    - Test `compose()` with output_schema includes schema section
    - Test StageContext creation with all fields
    - Test StageContext creation with minimal fields (None defaults)

    **tests/unit/test_confidence_scorer.py**:
    - Test scorer with high-quality scaffold → overall >= 0.6
    - Test scorer with missing files in scaffold → completeness low → overall < 0.6
    - Test scorer with forbidden imports → feasibility = 0 → overall < 0.6
    - Test scorer with no error handling → edge_case_handling low
    - Test `passes_threshold()` returns correct bool
    - Test custom threshold (0.8) rejects marginal scaffolds
    - Test `_compute_backoff()` returns values within expected range
    - Test `_compute_backoff()` adds jitter (multiple calls return different values)
  </action>
  <verify>
    `python -m pytest tests/unit/test_prompt_composer.py tests/unit/test_confidence_scorer.py -v --tb=short` — all pass.
  </verify>
  <done>
    18+ tests covering compose(), load_soul(), confidence scoring, backoff with jitter.
  </done>
</task>

</tasks>

<verification>
- `ls agents/souls/*.soul.md | wc -l` returns 3
- `python -c "from shared.agents.prompt_composer import compose, load_soul"` succeeds
- `python -c "from shared.agents.confidence import Blueprint2CodeScorer"` succeeds
- `grep -n "compose(" tools/builtin/module_builder.py | wc -l` >= 3
- `grep -n "_compute_backoff" shared/providers/llm_gateway.py` shows backoff function
- `python -m pytest tests/unit/test_prompt_composer.py tests/unit/test_confidence_scorer.py -v` — all pass
- `make test-self-evolution` — zero regressions
</verification>

<success_criteria>
- Three soul.md agent identity files are version-controlled artifacts
- compose() merges soul.md + stage context for every LLM call in the build pipeline
- Scaffold stage gated by Blueprint2Code confidence scorer (threshold 0.6)
- LLM Gateway uses bounded retry with jitter on transient failures
- 18+ tests passing for compose(), confidence scorer, and backoff
- Zero regressions in existing self-evolution test suite
</success_criteria>

<output>
After completion, create `.planning/phases/05-refactoring/05-02-SUMMARY.md`
</output>
