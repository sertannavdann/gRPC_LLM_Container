---
phase: 05-refactoring
plan: 04
type: execute
wave: 3
depends_on: [05-03]
files_modified:
  - dashboard_service/main.py
  - dashboard_service/requirements.txt
  - dashboard_service/pipeline_stream.py
  - orchestrator/admin_api.py
  - ui_service/src/components/pipeline/ServiceNode.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Dashboard starts even when opentelemetry-instrumentation-fastapi is not installed"
    - "Orchestrator no longer proxies module credential operations through dashboard HTTP"
    - "Pipeline SSE collection no longer self-probes dashboard and no longer duplicates module/adapter fetches"
    - "gRPC-discovered services use explicit unknown state (not misleading idle)"
    - "Pipeline ServiceNode UI explicitly supports unknown state"
  artifacts:
    - path: "dashboard_service/main.py"
      provides: "Conditional FastAPIInstrumentor import and guarded instrumentation call"
      min_lines: 300
    - path: "orchestrator/admin_api.py"
      provides: "Direct CredentialStore calls for has/store/delete in credential endpoints"
      min_lines: 700
    - path: "dashboard_service/pipeline_stream.py"
      provides: "Single-cycle data collection path without self-probe or duplicate loader/registry calls"
      min_lines: 120
    - path: "ui_service/src/components/pipeline/ServiceNode.tsx"
      provides: "unknown state color/icon/type support"
      min_lines: 40
  key_links:
    - from: "orchestrator/admin_api.py"
      to: "shared/modules/credentials.py"
      via: "uses _credential_store.has_credentials/store/delete directly"
      pattern: "_credential_store\\.(has_credentials|store|delete)"
    - from: "dashboard_service/pipeline_stream.py"
      to: "dashboard_service/main.py"
      via: "uses healthy orchestrator probe only; dashboard represented as local running service"
      pattern: "orchestrator|dashboard"
---

<objective>
Eliminate service-level dependency debt introduced by cross-service shortcuts in prior waves.

Purpose: Dashboard startup was brittle due to unconditional OpenTelemetry FastAPI instrumentation import. Orchestrator credential APIs created a circular dependency by proxying through dashboard endpoints instead of using local CredentialStore. Pipeline SSE loop performed redundant calls every 2 seconds and self-probed dashboard health. This wave removes circular runtime coupling and reduces SSE polling overhead.

Output: Dashboard boot no longer depends on optional instrumentation package, credential operations are local to orchestrator, SSE cycle cost is reduced by deduplicating calls and removing self-probe, and UI renders unknown service state explicitly.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-minimal.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-refactoring/05-CONTEXT.md

@dashboard_service/main.py
@dashboard_service/pipeline_stream.py
@orchestrator/admin_api.py
@shared/modules/credentials.py
@ui_service/src/components/pipeline/ServiceNode.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Guard optional OpenTelemetry FastAPI instrumentation</name>
  <files>dashboard_service/main.py, dashboard_service/requirements.txt</files>
  <action>
    Replace unconditional FastAPIInstrumentor import with try/except ImportError.
    Introduce `_HAS_FASTAPI_INSTRUMENTOR` boolean and guard `FastAPIInstrumentor.instrument_app(app)`.
    Keep warning log when optional dependency is absent.
  </action>
  <verify>
    `python -c "import dashboard_service.main"` succeeds without opentelemetry-instrumentation-fastapi.
    `grep -c "_HAS_FASTAPI_INSTRUMENTOR" dashboard_service/main.py` is >= 3.
  </verify>
  <done>
    Dashboard startup is resilient when optional instrumentation package is not installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove orchestratorâ†’dashboard credential proxy</name>
  <files>orchestrator/admin_api.py</files>
  <action>
    Replace `_check_module_credentials()` HTTP probe with direct `_credential_store.has_credentials(module_id)`.
    Replace `store_credentials()` HTTP POST proxy with `_credential_store.store(module_id, request.credentials)`.
    Replace `delete_credentials()` HTTP DELETE proxy with `_credential_store.delete(module_id)`.
    Replace uninstall best-effort dashboard call with local `_credential_store.delete(module_id)` cleanup.
    Remove helper `_dashboard_auth_headers()` and dead `requests as http_req` imports used only for the old proxy path.
  </action>
  <verify>
    `grep -c "dashboard.*module-credentials" orchestrator/admin_api.py` returns 0.
    `grep -c "_credential_store\\." orchestrator/admin_api.py` is >= 4.
  </verify>
  <done>
    Credential operations are local to orchestrator; circular dependency to dashboard is removed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Deduplicate pipeline SSE data collection</name>
  <files>dashboard_service/pipeline_stream.py</files>
  <action>
    Remove dashboard self-probe (`localhost:8001/health`) from pipeline stream loop.
    Keep orchestrator health probe and set dashboard service state synthetically to running.
    Call `adapter_registry.list_all_flat()` once per cycle and pass into adapter/tool builders.
    Call `loader.list_modules()` once per cycle and pass into adapter list builder.
    Set gRPC service state defaults from idle to unknown.
  </action>
  <verify>
    `grep -c "localhost:8001" dashboard_service/pipeline_stream.py` returns 0.
    `grep -c "list_all_flat" dashboard_service/pipeline_stream.py` returns 1.
    `grep -c '"idle"' dashboard_service/pipeline_stream.py` returns 0.
  </verify>
  <done>
    SSE loop no longer self-probes and runs a single module/adapter fetch per cycle.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add explicit unknown service state UI</name>
  <files>ui_service/src/components/pipeline/ServiceNode.tsx</files>
  <action>
    Add `unknown` to `ServiceNodeData.state` union.
    Add `unknown` entries to `stateColors` and `stateIcons` maps.
    Use `HelpCircle` icon for unknown state.
  </action>
  <verify>
    `grep -c "unknown" ui_service/src/components/pipeline/ServiceNode.tsx` is >= 2.
    `pnpm --filter ui_service build` succeeds.
  </verify>
  <done>
    Unknown service state is represented explicitly in the pipeline UI.
  </done>
</task>

</tasks>

<verification>
- `python -c "import dashboard_service.main"` succeeds without optional otel package
- `grep -c "dashboard.*module-credentials" orchestrator/admin_api.py` -> 0
- `grep -c "_credential_store\\." orchestrator/admin_api.py` -> >= 4
- `grep -c "localhost:8001" dashboard_service/pipeline_stream.py` -> 0
- `grep -c "list_all_flat" dashboard_service/pipeline_stream.py` -> 1
- `grep -c '"idle"' dashboard_service/pipeline_stream.py` -> 0
- `grep -c "unknown" ui_service/src/components/pipeline/ServiceNode.tsx` -> >= 1
- `pnpm --filter ui_service build` succeeds
</verification>

<success_criteria>
- Dashboard boot does not fail when optional FastAPI instrumentation package is missing
- Orchestrator credential APIs no longer depend on dashboard availability
- Pipeline SSE cycle no longer performs duplicate module/adapter collection or dashboard self-probe
- Unknown state is explicit in backend stream and frontend node rendering
- No regressions in existing build flow
</success_criteria>

<output>
After completion, create `.planning/phases/05-refactoring/05-04-SUMMARY.md`
</output>
