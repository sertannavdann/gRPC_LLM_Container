---
phase: 05-refactoring
plan: 05
type: execute
wave: 4
depends_on: [05-04]
files_modified:
  - tools/base.py
  - tools/builtin/context_bridge.py
  - tools/builtin/user_context.py
  - tools/builtin/web_tools.py
  - tools/builtin/knowledge_search.py
  - tools/builtin/knowledge_store.py
  - tools/builtin/math_solver.py
  - tools/builtin/code_executor.py
  - tools/builtin/module_pipeline.py
  - tools/builtin/module_admin.py
  - shared/adapters/base.py
  - shared/adapters/__init__.py
  - shared/adapters/finance/cibc.py
  - shared/adapters/weather/openweather.py
  - shared/adapters/calendar/google_calendar.py
  - shared/adapters/gaming/clashroyale.py
  - orchestrator/orchestrator_service.py
  - dashboard_service/aggregator.py
  - core/graph.py
files_deleted:
  - tools/builtin/destinations.py
  - tools/builtin/feature_test_harness.py
  - tools/builtin/chart_validator.py
  - tools/builtin/finance_query.py
  - tools/builtin/web_search.py
  - tools/builtin/web_loader.py
  - tools/builtin/module_builder.py
  - tools/builtin/module_validator.py
  - tools/builtin/module_installer.py
  - tools/builtin/module_manager.py
  - shared/adapters/finance/mock.py
  - shared/adapters/calendar/mock.py
  - shared/adapters/health/mock.py
  - shared/adapters/navigation/mock.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All tools inherit from BaseTool ABC with validate_input/execute_internal/format_output lifecycle"
    - "CompositeTool dispatches via Strategy pattern with ActionStrategy subclasses and dict lookup"
    - "ToolResult dataclass includes metadata field (duration_ms, tool_version, request_id)"
    - "27 registered tools consolidated to 8: UserContextTool, WebTool, ModulePipelineTool, ModuleAdminTool, KnowledgeSearchTool, KnowledgeStoreTool, MathSolverTool, CodeExecutorTool"
    - "ContextBridge is a class with __init__(dashboard_url), fetch(categories), normalize() methods"
    - "All 4 mock adapter files deleted and UserConfig defaults updated to empty lists"
    - "3 dead code files deleted: destinations.py, feature_test_harness.py, chart_validator.py"
    - "Each concrete adapter implements normalize_for_tools() method"
    - "finance_query absorbed into UserContextTool with category=finance action=query"
    - "web_search and load_web_page merged into single WebTool"
    - "All module builder/validator/installer functions consolidated into ModulePipelineTool"
    - "All module manager/draft/version functions consolidated into ModuleAdminTool"
    - "No inline mock data remains in any tool file"
    - "LocalToolRegistry unchanged — class instances registered via __call__ compatibility"
  artifacts:
    - path: "tools/base.py"
      provides: "BaseTool ABC, CompositeTool, ActionStrategy, updated ToolResult with metadata"
      min_lines: 200
    - path: "tools/builtin/context_bridge.py"
      provides: "ContextBridge class with fetch/normalize methods, injected into tools"
      min_lines: 80
    - path: "tools/builtin/user_context.py"
      provides: "UserContextTool(BaseTool) consolidating 4 tools + finance query"
      min_lines: 150
    - path: "tools/builtin/web_tools.py"
      provides: "WebTool(BaseTool) merging web_search + load_web_page"
      min_lines: 100
    - path: "tools/builtin/module_pipeline.py"
      provides: "ModulePipelineTool(CompositeTool) with build/write/repair/validate/install strategies"
      min_lines: 200
    - path: "tools/builtin/module_admin.py"
      provides: "ModuleAdminTool(CompositeTool) with list/enable/disable/credentials/drafts/versions strategies"
      min_lines: 200
    - path: "orchestrator/orchestrator_service.py"
      provides: "8 tool registrations replacing 27, with backward-compat aliases"
      min_lines: 900
  key_links:
    - from: "tools/base.py"
      to: "shared/adapters/base.py"
      via: "BaseTool mirrors BaseAdapter lifecycle pattern"
      pattern: "validate_input|execute_internal|format_output"
    - from: "tools/builtin/user_context.py"
      to: "tools/builtin/context_bridge.py"
      via: "UserContextTool receives ContextBridge via constructor injection"
      pattern: "ContextBridge"
    - from: "orchestrator/orchestrator_service.py"
      to: "tools/builtin/"
      via: "Creates tool instances and registers them with LocalToolRegistry"
      pattern: "tool_registry\\.register"
---

<objective>
Consolidate 27 registered tools into 8 via polymorphic BaseTool ABC hierarchy, eliminate all mock data and dead code, and fix OCP violation in context normalization.

Purpose: The tool layer has massive redundancy — 3 tools fetch the same context data, 13 module tools the LLM must choose between, 769 lines of dead code, and 4 mock adapters producing synthetic data alongside inline mock functions. The 6-category hardcoded switch in context_bridge violates OCP. This wave restructures all tools behind a universal BaseTool[TRequest, TResponse] ABC that mirrors the existing BaseAdapter[T] pattern, using CompositeTool with Strategy pattern for multi-action tools.

Output: 8 registered tools (down from 27), zero mock data in production, zero dead code files, ContextBridge as injectable service object, each adapter self-describes its normalization via normalize_for_tools().
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-minimal.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-refactoring/05-CONTEXT.md
@.planning/phases/05-refactoring/05-RESEARCH.md
@.planning/phases/05-refactoring/LIVE-AUDIT.md

@tools/base.py
@tools/registry.py
@tools/builtin/context_bridge.py
@tools/builtin/user_context.py
@tools/builtin/finance_query.py
@tools/builtin/web_search.py
@tools/builtin/web_loader.py
@tools/builtin/knowledge_search.py
@tools/builtin/code_executor.py
@tools/builtin/math_solver.py
@tools/builtin/module_builder.py
@tools/builtin/module_validator.py
@tools/builtin/module_installer.py
@tools/builtin/module_manager.py
@tools/builtin/destinations.py
@tools/builtin/feature_test_harness.py
@shared/adapters/base.py
@shared/adapters/__init__.py
@shared/adapters/finance/mock.py
@shared/adapters/calendar/mock.py
@shared/adapters/health/mock.py
@shared/adapters/navigation/mock.py
@orchestrator/orchestrator_service.py
@dashboard_service/aggregator.py
@core/graph.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend tools/base.py with BaseTool ABC, CompositeTool, ActionStrategy, and updated ToolResult</name>
  <files>tools/base.py</files>
  <action>
    Extend the existing `tools/base.py` file. Keep ALL existing code (ToolCallable, ToolError, BaseTool, IdempotencyCache, etc.) and ADD new classes.

    1. Update `ToolResult` dataclass:
       - Add `error: Optional[str] = None` field
       - Add `metadata: Dict[str, Any] = field(default_factory=dict)` field
       - Update `to_dict()` to include error and metadata (as `_metadata` key)

    2. Add `TRequest = TypeVar('TRequest', bound=BaseModel)` and `TResponse = TypeVar('TResponse', bound=BaseModel)` type variables (import from pydantic).

    3. Rename existing `BaseTool` class to `BaseToolLegacy` (backward compat). Create new `BaseTool(ABC, Generic[TRequest, TResponse])` class:
       - Class attributes: `name: str`, `description: str`, `version: str = "1.0.0"`, `RequestModel`, `ResponseModel`
       - Abstract methods: `validate_input(self, **kwargs) -> TRequest`, `execute_internal(self, request: TRequest) -> TResponse`, `format_output(self, response: TResponse) -> Dict[str, Any]`
       - Concrete `execute(self, **kwargs) -> Dict[str, Any]` that orchestrates lifecycle with timing, request_id, error handling. Returns dict with `status` key and `_metadata` dict.
       - Concrete `__call__(self, **kwargs) -> Dict[str, Any]` that delegates to `execute()`.
       - Concrete `get_schema(self) -> Dict[str, Any]` that returns tool schema for LLM.

    4. Add `ActionStrategy(ABC)` class:
       - `action_name: str = ""`, `description: str = ""`
       - Abstract `execute(self, **kwargs) -> Dict[str, Any]`

    5. Add `CompositeTool(BaseTool)` class:
       - `__init__` populates `self._strategies: Dict[str, ActionStrategy] = {}`
       - `_register_strategy(strategy)` adds to dict
       - `validate_input` checks `action` param exists and is in `_strategies`
       - `execute_internal` dispatches to `strategy.execute(**kwargs)`
       - `format_output` passes through (strategies return complete dicts)

    CRITICAL: Import `from abc import ABC, abstractmethod` and `from typing import Generic, TypeVar`. Import `from pydantic import BaseModel, ValidationError`. Use `import time, uuid` inside execute() method body to avoid top-level import issues.
  </action>
  <verification>
    - `BaseTool` is abstract with 3 abstract methods
    - `CompositeTool` extends `BaseTool` and dispatches via dict lookup
    - `ToolResult.to_dict()` includes `_metadata` and `error` keys
    - Existing `ToolCallable`, `ToolError`, `IdempotencyCache` are untouched
    - `BaseToolLegacy` preserves old `BaseTool` interface for any lingering references
  </verification>
</task>

<task type="auto">
  <name>Task 2: Delete dead code files</name>
  <files>tools/builtin/destinations.py, tools/builtin/feature_test_harness.py, tools/builtin/chart_validator.py</files>
  <action>
    Delete these 3 files — they are never registered as tools and have no call path from the orchestrator:
    1. `tools/builtin/destinations.py` (137 lines) — never registered
    2. `tools/builtin/feature_test_harness.py` (253 lines) — never called
    3. `tools/builtin/chart_validator.py` (379 lines) — never registered

    Also check `tools/builtin/__init__.py` for any imports of these modules and remove them.
    Check `orchestrator/orchestrator_service.py` for any imports of these modules and remove them.

    CRITICAL: grep for any other files that import from these modules. If found, remove those imports.
  </action>
  <verification>
    - All 3 files deleted
    - No ImportError when importing tools.builtin
    - No references to deleted files remain in the codebase
  </verification>
</task>

<task type="auto">
  <name>Task 3: Refactor ContextBridge to class, add normalize_for_tools to adapters, delete mock adapters</name>
  <files>tools/builtin/context_bridge.py, shared/adapters/base.py, shared/adapters/__init__.py, shared/adapters/finance/cibc.py, shared/adapters/weather/openweather.py, shared/adapters/calendar/google_calendar.py, shared/adapters/gaming/clashroyale.py, shared/adapters/finance/mock.py, shared/adapters/calendar/mock.py, shared/adapters/health/mock.py, shared/adapters/navigation/mock.py, dashboard_service/aggregator.py</files>
  <action>
    **Part A: ContextBridge class**
    Replace `context_bridge.py` module functions with a `ContextBridge` class:
    - `__init__(self, dashboard_url=None, api_key=None, timeout=10)` — reads from env vars as fallback
    - `fetch(self, categories=None, user_id="default") -> Dict[str, Any]` — HTTP GET to dashboard /context endpoint. If `USE_MOCK_CONTEXT` env var is true, return `{}`.
    - `normalize(self, raw: Dict[str, Any]) -> Dict[str, Any]` — calls adapter `normalize_for_tools()` classmethods per category. Replaces the hardcoded 6-category switch.
    - `fetch_and_normalize(self, categories=None) -> Dict[str, Any]` — convenience method combining fetch + normalize.
    - Keep the `_headers` property for API key injection.

    **Part B: Add normalize_for_tools to BaseAdapter**
    In `shared/adapters/base.py`, add a NON-abstract method to `BaseAdapter`:
    ```python
    def normalize_for_tools(self, raw_category_data: Dict[str, Any]) -> Dict[str, Any]:
        """Transform adapter data for tool consumption. Override in subclasses."""
        return raw_category_data  # Default pass-through
    ```
    Also add it as a `@classmethod` alternative so ContextBridge can call it without an instance:
    ```python
    @classmethod
    def normalize_category_for_tools(cls, raw_category_data: Dict[str, Any]) -> Dict[str, Any]:
        return raw_category_data
    ```

    **Part C: Implement normalize_for_tools on each real adapter**
    Migrate the normalization logic from the old `_normalize_context_for_tools()` function in context_bridge.py to each adapter class:
    - `CIBCAdapter.normalize_category_for_tools()` — finance data normalization
    - `OpenWeatherAdapter.normalize_category_for_tools()` — weather data normalization
    - `GoogleCalendarAdapter.normalize_category_for_tools()` — calendar data normalization
    - `ClashRoyaleAdapter.normalize_category_for_tools()` — gaming data normalization

    **Part D: Delete all mock adapters**
    1. Delete files: `shared/adapters/finance/mock.py`, `shared/adapters/calendar/mock.py`, `shared/adapters/health/mock.py`, `shared/adapters/navigation/mock.py`
    2. Update `shared/adapters/__init__.py` — remove mock adapter imports and `__all__` entries
    3. Update `dashboard_service/aggregator.py` `UserConfig` defaults:
       - `finance: ["cibc"]` (remove "mock")
       - `calendar: []` (was `["mock"]`)
       - `health: []` (was `["mock"]`)
       - `navigation: []` (was `["mock"]`)
    4. Remove mock fallback logic in aggregator if present.

    **Part E: Wire ContextBridge.normalize()**
    In `ContextBridge.normalize()`, import adapter classes from `shared/adapters/` and call their `normalize_category_for_tools()` classmethods. Use a registry-style lookup: map category name to adapter class. For categories without a real adapter (health, navigation), return `{"status": "no adapter configured"}`.

    CRITICAL: Check for test files that import mock adapters. Update test imports to use inline MockAdapter fixtures instead.
  </action>
  <verification>
    - `ContextBridge` class instantiable with dashboard_url
    - `normalize_for_tools()` exists on BaseAdapter (non-abstract, returns raw data by default)
    - Each real adapter (CIBC, OpenWeather, GoogleCalendar, ClashRoyale) overrides normalize_category_for_tools
    - All 4 mock adapter files deleted
    - `shared/adapters/__init__.py` has no mock imports
    - `UserConfig` defaults have no "mock" entries
    - No `_normalize_context_for_tools()` function remains in context_bridge.py
  </verification>
</task>

<task type="auto">
  <name>Task 4: Build all 8 consolidated tool classes</name>
  <files>tools/builtin/user_context.py, tools/builtin/web_tools.py, tools/builtin/knowledge_search.py, tools/builtin/knowledge_store.py, tools/builtin/math_solver.py, tools/builtin/code_executor.py, tools/builtin/module_pipeline.py, tools/builtin/module_admin.py</files>
  <action>
    Build each of the 8 tool classes inheriting from BaseTool or CompositeTool. Each tool must:
    - Define `name`, `description`, `version` class attributes
    - Define `RequestModel(BaseModel)` and optionally `ResponseModel(BaseModel)`
    - Implement `validate_input()`, `execute_internal()`, `format_output()`
    - Accept dependencies via `__init__` constructor injection (no global state, no set_* functions)

    **4a: UserContextTool(BaseTool)** — `tools/builtin/user_context.py`
    - REPLACE entire file contents (delete old functions and inline mock data)
    - Receives `ContextBridge` via constructor
    - `RequestModel`: category (str, default "all"), action (str, default "summary"), destination (Optional[str]), include_alerts (bool), plus finance query params (search, sort, sort_dir, page, per_page, group_by, date_from, date_to)
    - When `category="all"` and `action="summary"`: fetch all categories via bridge, build daily briefing format
    - When `category="finance"` and `action="query"`: make HTTP request to dashboard `/bank/*` endpoints with pagination params
    - When `category="navigation"`: include destination in context fetch
    - Absorbs ALL logic from old get_user_context, get_daily_briefing, get_commute_time, and finance_query

    **4b: WebTool(BaseTool)** — `tools/builtin/web_tools.py` (NEW file)
    - Receives no dependencies (stateless)
    - `RequestModel`: action (str: "search" | "load"), query (Optional[str]), url (Optional[str]), num_results (int, default 5), extract_links (bool, default False), max_chars (int, default 8000)
    - When `action="search"`: migrates logic from `web_search.py`
    - When `action="load"`: migrates logic from `web_loader.py`
    - After this file works, delete `web_search.py` and `web_loader.py`

    **4c: KnowledgeSearchTool(BaseTool)** — `tools/builtin/knowledge_search.py`
    - REFACTOR existing file to class-based
    - Receives chroma_client or connection params via constructor
    - Keeps `search_knowledge` logic

    **4d: KnowledgeStoreTool(BaseTool)** — `tools/builtin/knowledge_store.py` (NEW file)
    - Split from knowledge_search.py
    - Receives same chroma_client
    - Keeps `store_knowledge` logic

    **4e: MathSolverTool(BaseTool)** — `tools/builtin/math_solver.py`
    - REFACTOR existing file to class-based
    - Stateless, no dependencies

    **4f: CodeExecutorTool(BaseTool)** — `tools/builtin/code_executor.py`
    - REFACTOR existing file to class-based
    - Receives sandbox_client via constructor

    **4g: ModulePipelineTool(CompositeTool)** — `tools/builtin/module_pipeline.py` (NEW file)
    - 5 ActionStrategy subclasses: BuildStrategy, WriteCodeStrategy, RepairStrategy, ValidateStrategy, InstallStrategy
    - Receives `llm_gateway`, `sandbox_client`, `modules_dir`, `audit_dir` via constructor
    - Each strategy migrates logic from old module_builder.py, module_validator.py, module_installer.py
    - After this file works, delete old files

    **4h: ModuleAdminTool(CompositeTool)** — `tools/builtin/module_admin.py` (NEW file)
    - 12 ActionStrategy subclasses: ListStrategy, EnableStrategy, DisableStrategy, CredentialStrategy, UninstallStrategy, CreateDraftStrategy, EditDraftStrategy, DiffDraftStrategy, ValidateDraftStrategy, PromoteDraftStrategy, ListVersionsStrategy, RollbackVersionStrategy
    - Receives `module_loader`, `module_registry`, `credential_store`, `draft_manager`, `version_manager` via constructor
    - Each strategy migrates logic from old module_manager.py, module_installer.py (uninstall), and draft/version closures in orchestrator
    - After this file works, delete old module_manager.py and module_installer.py

    CRITICAL for all tools:
    - `__call__(**kwargs)` returns `Dict[str, Any]` with `status` key — satisfies LocalToolRegistry contract
    - Do NOT break existing logic — migrate function bodies directly into execute_internal or strategy.execute
    - Global variables (`_llm_gateway`, `_sandbox_client`, etc.) replaced by constructor-injected instance attributes
    - Remove all `set_*` functions (set_llm_gateway, set_sandbox_client, etc.)
  </action>
  <verification>
    - All 8 tool classes instantiable with their required dependencies
    - Each tool's `__call__(**kwargs)` returns dict with `status` key
    - UserContextTool handles all 4 previous tool use cases (context, briefing, commute, finance query)
    - WebTool handles both search and load actions
    - ModulePipelineTool dispatches build/write/repair/validate/install via strategies
    - ModuleAdminTool dispatches all 12 admin actions via strategies
    - No `_get_mock_context()` function exists anywhere
    - No `set_llm_gateway()` or similar set_* functions exist
  </verification>
</task>

<task type="auto">
  <name>Task 5: Rewire orchestrator registration, update graph.py references, clean up old files</name>
  <files>orchestrator/orchestrator_service.py, core/graph.py, tools/builtin/__init__.py</files>
  <action>
    **Part A: Rewire orchestrator_service.py**
    Replace the tool registration block (lines ~944-1147) with new class-based registration:

    1. Create ContextBridge instance:
       ```python
       _context_bridge = ContextBridge(dashboard_url=os.getenv("DASHBOARD_URL", "http://dashboard:8001"))
       ```

    2. Create 8 tool instances with constructor injection:
       - `UserContextTool(context_bridge=_context_bridge)`
       - `WebTool()`
       - `KnowledgeSearchTool(...)` with chroma params
       - `KnowledgeStoreTool(...)` with chroma params
       - `MathSolverTool()`
       - `CodeExecutorTool(sandbox_client=self.sandbox_client)`
       - `ModulePipelineTool(llm_gateway=self.llm_gateway, sandbox_client=self.sandbox_client, modules_dir=MODULES_DIR, audit_dir=...)`
       - `ModuleAdminTool(module_loader=..., module_registry=..., credential_store=..., draft_manager=_dm, version_manager=_vm)`

    3. Register each instance with explicit name and description:
       ```python
       self.tool_registry.register(_user_context_tool, name="user_context", description=_user_context_tool.description)
       ```

    4. Add backward-compatibility aliases for old tool names:
       ```python
       # Aliases for backward compat (remove after stable)
       self.tool_registry.register(_user_context_tool, name="get_user_context", description="Get user context data")
       self.tool_registry.register(_user_context_tool, name="get_daily_briefing", description="Get daily briefing")
       self.tool_registry.register(_user_context_tool, name="get_commute_time", description="Get commute time")
       self.tool_registry.register(_user_context_tool, name="query_finance", description="Query finance data")
       ```

    5. Remove the `_register_draft_version_tools()` method entirely (logic moved to ModuleAdminTool).
    6. Remove all `set_llm_gateway()`, `set_sandbox_client()`, etc. calls — dependencies now injected via constructors.
    7. Remove all imports of old tool modules (module_builder, module_validator, module_installer, module_manager, web_search, web_loader, finance_query, destinations).

    **Part B: Update core/graph.py**
    - Check `_is_module_build_session()` for old tool name references (`build_module`, `write_module_code`, etc.). Update to check for `module_pipeline` action names.
    - Check `_should_use_tools()` keyword lists — these use natural language keywords, not tool names, so likely no change needed.
    - The `_tools_node` function calls `registry.get(tool_name)` then `tool(**tool_args)` — this works unchanged because class instances implement `__call__`.

    **Part C: Clean up old tool files**
    Delete the following files (their logic is now in the new consolidated tools):
    - `tools/builtin/web_search.py`
    - `tools/builtin/web_loader.py`
    - `tools/builtin/finance_query.py`
    - `tools/builtin/module_builder.py`
    - `tools/builtin/module_validator.py`
    - `tools/builtin/module_installer.py`
    - `tools/builtin/module_manager.py`

    Update `tools/builtin/__init__.py` to remove imports of deleted modules and add imports of new tool classes.

    **Part D: Update intent_patterns.py if needed**
    Check `orchestrator/intent_patterns.py` for tool name references. Update any references to old tool names.
  </action>
  <verification>
    - `orchestrator_service.py` registers exactly 8 primary tools + backward-compat aliases
    - No import of old module files remains in orchestrator_service.py
    - No `set_llm_gateway` or `set_sandbox_client` calls remain
    - `_register_draft_version_tools()` method is removed
    - `graph.py` _is_module_build_session() uses new tool names
    - All 7 old tool files deleted
    - No ImportError on startup
    - `tools/builtin/__init__.py` exports new tool classes
  </verification>
</task>

</tasks>

<verification>
  Run these checks after all tasks complete:

  1. **Import check**: `python -c "from tools.base import BaseTool, CompositeTool, ActionStrategy, ToolResult"` — must succeed
  2. **Tool instantiation**: `python -c "from tools.builtin.user_context import UserContextTool; from tools.builtin.context_bridge import ContextBridge; t = UserContextTool(context_bridge=ContextBridge()); print(t.name)"` — must print "user_context"
  3. **No dead code**: `ls tools/builtin/destinations.py tools/builtin/feature_test_harness.py tools/builtin/chart_validator.py 2>&1 | grep -c "No such file"` — must return 3
  4. **No mock adapters**: `ls shared/adapters/finance/mock.py shared/adapters/calendar/mock.py shared/adapters/health/mock.py shared/adapters/navigation/mock.py 2>&1 | grep -c "No such file"` — must return 4
  5. **No old tool files**: `ls tools/builtin/web_search.py tools/builtin/web_loader.py tools/builtin/finance_query.py tools/builtin/module_builder.py tools/builtin/module_validator.py tools/builtin/module_installer.py tools/builtin/module_manager.py 2>&1 | grep -c "No such file"` — must return 7
  6. **Registry compat**: Verify `LocalToolRegistry.register(tool_instance, name="x")` works with class instances that implement `__call__`
  7. **Docker build**: `docker compose build orchestrator dashboard` — must succeed
  8. **Existing tests**: Run `python -m pytest tests/unit/ -x --timeout=30` — must not regress on unmodified tests
</verification>
