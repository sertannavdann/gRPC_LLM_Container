---
phase: 05-ui-contract-alignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - orchestrator/admin_api.py
  - shared/contracts/__init__.py
  - shared/contracts/ui_capability_schema.py
  - tests/unit/test_capability_contract.py
  - docs/ui_contract.md
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GET /capabilities returns a typed envelope with tools, modules, providers, and features with health status"
    - "GET /feature-health returns per-feature readiness with degraded reasons"
    - "GET /config/version returns an ETag header for conditional polling"
    - "Capability envelope reflects actual live state — not hardcoded stubs"
  artifacts:
    - path: "shared/contracts/ui_capability_schema.py"
      provides: "Pydantic models for capability envelope"
      exports: ["CapabilityEnvelope", "ToolCapability", "ModuleCapability", "ProviderCapability", "FeatureHealth"]
    - path: "orchestrator/admin_api.py"
      provides: "Three new BFF endpoints wired to existing registries"
      contains: "/capabilities"
    - path: "tests/unit/test_capability_contract.py"
      provides: "Contract validation tests"
      min_lines: 80
    - path: "docs/ui_contract.md"
      provides: "Contract documentation for UI developers"
      min_lines: 50
  key_links:
    - from: "orchestrator/admin_api.py"
      to: "shared/contracts/ui_capability_schema.py"
      via: "import CapabilityEnvelope"
      pattern: "from shared\\.contracts\\.ui_capability_schema import"
    - from: "orchestrator/admin_api.py"
      to: "shared/modules/registry.py"
      via: "reads module state for capability envelope"
      pattern: "registry\\.(list|get)"
    - from: "orchestrator/admin_api.py"
      to: "shared/auth/middleware.py"
      via: "RBAC enforcement on capability endpoints"
      pattern: "Depends\\(get_current_user\\)"
---

<objective>
Create the backend capability contract that makes the UI truthful.

Purpose: The UI currently hardcodes assumptions about what features/modules/providers exist and their state. This plan creates three BFF endpoints (`GET /capabilities`, `GET /feature-health`, `GET /config/version`) that expose the actual live state of the system as a typed contract. All subsequent UI plans consume this contract instead of making assumptions.

Output: Pydantic schema package (`shared/contracts/`), three new Admin API endpoints, unit tests, contract documentation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@orchestrator/admin_api.py
@shared/modules/registry.py
@shared/auth/middleware.py
@shared/auth/rbac.py
@shared/billing/usage_store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Capability schema + contract endpoints</name>
  <files>
    shared/contracts/__init__.py
    shared/contracts/ui_capability_schema.py
    orchestrator/admin_api.py
  </files>
  <action>
    Create `shared/contracts/` package with Pydantic v2 models:

    **CapabilityEnvelope**:
    - `tools: list[ToolCapability]` — registered orchestrator tools (build_module, repair_module, etc.) with name, description, enabled status
    - `modules: list[ModuleCapability]` — from registry: id, name, category, platform, status (INSTALLED/VALIDATED/FAILED/DISABLED), has_credentials, last_used, failure_count
    - `providers: list[ProviderCapability]` — from routing config: name, locked status (from ProviderUnlockBase pattern), connection_status (connected/locked/error), available_models, active_model
    - `features: list[FeatureHealth]` — named features with readiness status (healthy/degraded/unavailable) and degraded_reasons list
    - `config_version: str` — SHA-256 hash of serialized state for ETag
    - `timestamp: datetime`

    **FeatureHealth** — name, status enum (healthy/degraded/unavailable), degraded_reasons: list[str], last_checked: datetime

    **In `orchestrator/admin_api.py`**, add three endpoints (use existing patterns — `_app`, `Depends(get_current_user)`, etc.):

    1. `GET /admin/capabilities` — builds CapabilityEnvelope from:
       - Module registry (`list_modules()`)
       - Provider config (from `get_providers()` logic)
       - Feature health (derived: e.g., "self-evolution" is degraded if LLM gateway has no configured provider)
       - Sets `ETag` response header from `config_version`
       - Supports `If-None-Match` → returns 304 if ETag matches

    2. `GET /admin/feature-health` — subset of capabilities: just features array with readiness + reasons

    3. `GET /admin/config/version` — returns `{ version: str, etag: str }` for lightweight polling

    Feature health derivation rules:
    - "auth": healthy if API key store initialized
    - "metering": healthy if usage_store accessible
    - "self-evolution": degraded if no LLM provider configured, unavailable if sandbox service unreachable
    - "modules": degraded if any module has failure_count > 0
    - "monitoring": healthy if Prometheus endpoint responds

    **Important**: Reuse existing `_get_mgr()`, registry access patterns, and auth decorators. Do NOT duplicate logic from `get_providers()` or `list_modules()` — call them internally.
  </action>
  <verify>
    pytest tests/unit/test_capability_contract.py -q
    curl -s http://localhost:8003/admin/capabilities | python -m json.tool | head -30
    curl -s -I http://localhost:8003/admin/config/version | grep ETag
  </verify>
  <done>
    GET /admin/capabilities returns typed envelope reflecting live module/provider/feature state.
    GET /admin/feature-health returns per-feature readiness with degraded reasons.
    GET /admin/config/version returns ETag for conditional polling.
    ETag-based 304 responses work when state hasn't changed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Contract tests + documentation</name>
  <files>
    tests/unit/test_capability_contract.py
    docs/ui_contract.md
  </files>
  <action>
    **Tests** (`tests/unit/test_capability_contract.py`):
    - Test CapabilityEnvelope Pydantic model validates correctly with sample data
    - Test FeatureHealth enum values (healthy/degraded/unavailable)
    - Test ETag generation is deterministic (same state → same hash)
    - Test ETag changes when module state changes
    - Test feature health derivation: mock registry with failed module → "modules" feature degraded
    - Test feature health: no LLM provider → "self-evolution" degraded
    - Test 304 response when If-None-Match matches current ETag
    - Test capability envelope includes all registered tools
    - Test providers list includes lock status from ProviderUnlockBase pattern

    **Documentation** (`docs/ui_contract.md`):
    - Endpoint reference (URL, method, auth, response shape)
    - ETag polling protocol (If-None-Match header, 304 handling, 30s interval)
    - Feature health status meanings and when each status applies
    - Example curl commands for each endpoint
    - TypeScript type definitions matching the Pydantic models (for UI developers to reference)
    - Error taxonomy preview (NOT_AUTHORIZED, NOT_CONFIGURED, DEGRADED_PROVIDER, etc.)
    
    **Tool usage note for user**: This task is pure backend Python — use **Cursor Pro** Composer to implement. Cursor can read the existing admin_api.py (1240 lines), understand the registry/provider/auth patterns, and add endpoints respecting existing decorators and middleware.
  </action>
  <verify>
    pytest tests/unit/test_capability_contract.py -v
    cat docs/ui_contract.md | wc -l  # should be 50+ lines
  </verify>
  <done>
    9+ unit tests pass covering schema validation, ETag determinism, feature health derivation, and 304 responses.
    Contract documentation exists with endpoint reference, polling protocol, and TypeScript type hints for UI devs.
  </done>
</task>

</tasks>

<verification>
- `pytest tests/unit/test_capability_contract.py -v` — all tests pass
- `curl -s http://localhost:8003/admin/capabilities` returns valid JSON with tools, modules, providers, features arrays
- `curl -s -H "If-None-Match: <etag>" http://localhost:8003/admin/capabilities` returns 304 when state unchanged
- `docs/ui_contract.md` exists with endpoint reference and TypeScript types
</verification>

<success_criteria>
- Backend capability contract is the single source of truth for UI rendering
- ETag-based conditional fetch prevents unnecessary data transfer
- Feature health correctly reflects degraded/unavailable states
- Contract is documented for v0/Cursor workflow consumption
</success_criteria>

<output>
After completion, create `.planning/phases/05-ui-contract-alignment/05-01-SUMMARY.md`
</output>
