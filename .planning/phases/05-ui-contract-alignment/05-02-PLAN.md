---
phase: 05-ui-contract-alignment
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - ui_service/src/lib/adminClient.ts
  - ui_service/src/hooks/useCapabilities.ts
  - ui_service/src/lib/errors.ts
  - ui_service/src/components/ui/error-states.tsx
  - ui_service/src/app/capabilities/page.tsx
  - ui_service/src/app/modules/page.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "adminClient.ts has typed methods for GET /capabilities with ETag caching"
    - "useCapabilities hook provides live capability state to any component with 30s polling"
    - "Error taxonomy types exist and map to UI toast/banner variants"
    - "/capabilities page renders system capability cards driven by real backend data"
    - "/modules page renders module list with lifecycle actions driven by real backend data"
  artifacts:
    - path: "ui_service/src/lib/adminClient.ts"
      provides: "Extended admin client with capability fetch + ETag caching"
      contains: "getCapabilities"
    - path: "ui_service/src/hooks/useCapabilities.ts"
      provides: "React hook for capability polling with ETag"
      exports: ["useCapabilities"]
    - path: "ui_service/src/lib/errors.ts"
      provides: "Structured error taxonomy types"
      exports: ["NexusError", "ErrorCode"]
    - path: "ui_service/src/components/ui/error-states.tsx"
      provides: "Error/degraded/empty state components"
      exports: ["DegradedBanner", "EmptyState", "TimeoutSkeleton"]
    - path: "ui_service/src/app/capabilities/page.tsx"
      provides: "System capabilities dashboard page"
      min_lines: 60
    - path: "ui_service/src/app/modules/page.tsx"
      provides: "Module browser with lifecycle panel"
      min_lines: 80
  key_links:
    - from: "ui_service/src/hooks/useCapabilities.ts"
      to: "ui_service/src/lib/adminClient.ts"
      via: "calls getCapabilities with ETag"
      pattern: "adminApi\\.getCapabilities"
    - from: "ui_service/src/app/capabilities/page.tsx"
      to: "ui_service/src/hooks/useCapabilities.ts"
      via: "uses useCapabilities hook"
      pattern: "useCapabilities\\("
    - from: "ui_service/src/app/modules/page.tsx"
      to: "ui_service/src/lib/adminClient.ts"
      via: "calls module lifecycle endpoints"
      pattern: "adminApi\\."
---

<objective>
Create the capability-driven UI infrastructure and rewrite the first two pages (capabilities dashboard + module browser).

Purpose: This plan establishes the foundational UI patterns — admin client extensions, capability polling hook, error taxonomy — then applies them to two key pages. All subsequent page rewrites follow these patterns.

Output: Extended adminClient with ETag support, useCapabilities hook, error taxonomy, two new pages (/capabilities, /modules).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ui-contract-alignment/05-01-SUMMARY.md

@ui_service/src/lib/adminClient.ts
@ui_service/src/store/nexusStore.ts
@ui_service/src/hooks/useDashboard.ts
@ui_service/src/components/ui/button.tsx
@docs/ui_contract.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Admin client extension + capability hook + error taxonomy</name>
  <files>
    ui_service/src/lib/adminClient.ts
    ui_service/src/hooks/useCapabilities.ts
    ui_service/src/lib/errors.ts
    ui_service/src/components/ui/error-states.tsx
  </files>
  <action>
    **Extend `adminClient.ts`** — add to existing `adminApi` object (do NOT create a new file):
    - `getCapabilities(etag?: string)`: fetches `GET /admin/capabilities` with `If-None-Match` header when etag provided. Returns `{ data: CapabilityEnvelope | null, etag: string, notModified: boolean }`. On 304, returns `{ data: null, etag, notModified: true }`.
    - `getFeatureHealth()`: fetches `GET /admin/feature-health`
    - `getConfigVersion()`: fetches `GET /admin/config/version`
    - Add TypeScript interfaces matching the Pydantic models from Plan 01: `CapabilityEnvelope`, `ToolCapability`, `ModuleCapability`, `ProviderCapability`, `FeatureHealth`, `FeatureStatus`

    **Create `useCapabilities` hook** (`ui_service/src/hooks/useCapabilities.ts`):
    - Polls `getCapabilities()` every 30 seconds using `setInterval`
    - Stores last ETag, sends `If-None-Match` on subsequent requests
    - On 304 (notModified), keeps previous state — no re-render
    - Exposes: `{ capabilities, features, providers, modules, tools, isLoading, error, lastUpdated, refetch }`
    - Handles errors gracefully: on fetch failure, preserves last known state + sets error
    - Uses `useEffect` cleanup to clear interval on unmount

    **Create error taxonomy** (`ui_service/src/lib/errors.ts`):
    - `ErrorCode` enum: `NOT_AUTHORIZED`, `NOT_CONFIGURED`, `DEGRADED_PROVIDER`, `TOOL_SCHEMA_MISMATCH`, `TIMEOUT`, `NETWORK_ERROR`, `UNKNOWN`
    - `NexusError` class extending Error with `code: ErrorCode`, `details?: Record<string, unknown>`
    - `classifyError(status: number, body?: string): ErrorCode` — maps HTTP status to error code
    - `getErrorMessage(code: ErrorCode): string` — user-friendly messages

    **Create error state components** (`ui_service/src/components/ui/error-states.tsx`):
    - `DegradedBanner({ feature, reasons })` — yellow warning banner showing degraded feature name + reasons
    - `EmptyState({ title, description, action? })` — centered empty state card with optional action button
    - `TimeoutSkeleton({ message? })` — loading skeleton with timeout message after 10s
    - `ErrorToast({ error: NexusError })` — maps error code to toast styling (red for auth, yellow for degraded, orange for timeout)
    - Use existing Tailwind classes + lucide-react icons. Do NOT add new dependencies.
    
    **Tool usage note**: Use **Cursor Pro** for adminClient.ts extension (it needs to understand the existing 132-line file and extend `adminApi` in-place). Use **v0** to generate the error-states component visuals, then paste into repo and let Cursor wire the error code mapping.
  </action>
  <verify>
    npx tsc --noEmit --project ui_service/tsconfig.json 2>&1 | head -20
    grep -c "getCapabilities" ui_service/src/lib/adminClient.ts  # should be >= 1
    grep -c "useCapabilities" ui_service/src/hooks/useCapabilities.ts  # should be >= 1
  </verify>
  <done>
    adminClient.ts exports getCapabilities/getFeatureHealth/getConfigVersion with ETag support.
    useCapabilities hook polls every 30s with ETag-based conditional fetch.
    Error taxonomy and error state components exist and compile.
  </done>
</task>

<task type="auto">
  <name>Task 2: Capabilities dashboard + Module browser pages</name>
  <files>
    ui_service/src/app/capabilities/page.tsx
    ui_service/src/app/modules/page.tsx
  </files>
  <action>
    **Page 1: System Capabilities Dashboard (`/capabilities`)**
    
    v0 prompt to generate visual shell:
    ```
    "Next.js 14 App Router page using shadcn/ui. Dashboard grid showing system capabilities as cards. Each card has: feature name, status badge (healthy green / degraded yellow / unavailable red), provider name, latency indicator, last-checked timestamp, and an action button. Include a top bar with search/filter by status. Responsive 1→2→3 column grid. Dark mode support. Use Tailwind."
    ```
    
    After pasting v0 output, wire with Cursor:
    - Import and use `useCapabilities()` hook for all data
    - Map `FeatureHealth.status` to badge color variants (healthy=green, degraded=yellow, unavailable=red)
    - Wire search/filter to filter `capabilities.features` array client-side
    - Wire action buttons to relevant Admin API endpoints (e.g., reload module, test provider connection)
    - Show `DegradedBanner` at top if any feature is degraded
    - Show `TimeoutSkeleton` while initial load
    - Handle error state with `EmptyState` component

    **Page 2: Module Browser + Lifecycle Panel (`/modules`)**
    
    v0 prompt to generate visual shell:
    ```
    "Next.js page with shadcn/ui. Left sidebar lists modules by category (weather, gaming, finance, calendar) with status chips (INSTALLED/VALIDATED/FAILED/DISABLED). Right panel shows selected module detail: manifest fields, version history timeline, current status, action buttons (edit draft, validate, promote, rollback, uninstall). Include a 'Dev Mode' toggle that reveals a code diff viewer area."
    ```
    
    After pasting v0 output, wire with Cursor:
    - Fetch module list from `useCapabilities().modules` (from capability envelope) for status overview
    - Fetch detailed module data from `adminApi.getModule(category, platform)` on selection
    - Wire lifecycle actions to existing Admin API endpoints:
      - Draft create: `POST /admin/modules/{cat}/{plat}/drafts`
      - Validate: `POST /admin/modules/{cat}/{plat}/drafts/{id}/validate`
      - Promote: `POST /admin/modules/{cat}/{plat}/drafts/{id}/promote`
      - Rollback: `POST /admin/modules/{cat}/{plat}/rollback`
      - Diff: `GET /admin/modules/{cat}/{plat}/drafts/{id}/diff`
    - Gate actions by user role:
      - Draft create/edit: operator+
      - Validate/promote/rollback: admin+
      - View: all roles
    - Show status chip colors: INSTALLED=green, VALIDATED=blue, FAILED=red, DISABLED=gray
    - Dev Mode toggle shows diff viewer area (placeholder for now, wired in polish plan)
    
    **Tool usage note**: Generate BOTH page shells in **v0** first (use the prompts above). Then use **Cursor Composer** in a single session to wire both pages, since they share the `useCapabilities` hook and `adminClient` — Cursor can edit all files together.
  </action>
  <verify>
    npx tsc --noEmit --project ui_service/tsconfig.json 2>&1 | head -20
    curl -s http://localhost:3000/capabilities | head -5  # should render HTML
    curl -s http://localhost:3000/modules | head -5  # should render HTML
  </verify>
  <done>
    /capabilities page renders system capability cards from live backend data with status badges, search/filter, and action buttons.
    /modules page renders module list by category with lifecycle action buttons gated by RBAC role.
    Both pages use useCapabilities hook and handle loading/error/degraded states.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no type errors
- /capabilities page loads and shows feature health cards from GET /admin/capabilities
- /modules page shows module list, clicking a module shows detail panel
- ETag polling works: after initial load, subsequent polls return 304 when state unchanged
- Error states render correctly when backend is unreachable or returns errors
</verification>

<success_criteria>
- Two new pages render exclusively from capability contract data (no hardcoded state)
- useCapabilities hook is reusable across all pages needing capability data
- Error taxonomy is consistent and maps to visual components
- v0 visual shells are wired to real APIs via Cursor
</success_criteria>

<output>
After completion, create `.planning/phases/05-ui-contract-alignment/05-02-SUMMARY.md`
</output>
