---
phase: 05-ui-contract-alignment
plan: 05
type: execute
wave: 3
depends_on: ["05-02", "05-03", "05-04"]
files_modified:
  - shared/auth/user_prefs.py
  - orchestrator/admin_api.py
  - ui_service/src/hooks/useUserPrefs.ts
  - ui_service/src/lib/adminClient.ts
  - ui_service/src/app/layout.tsx
  - ui_service/src/components/nav/Navbar.tsx
autonomous: false

must_haves:
  truths:
    - "User preferences (dashboard layout, provider ordering, favorites, theme) persist across sessions"
    - "PUT /admin/user/prefs saves preferences with optimistic concurrency (version check)"
    - "Context 401s show degraded state banner instead of silent failure"
    - "No valid JSON responses show warning banner instead of blank page"
    - "High-latency responses show loading skeleton with timeout message"
    - "All 5 rewritten pages render correctly against live orchestrator"
  artifacts:
    - path: "shared/auth/user_prefs.py"
      provides: "SQLite user preferences store with optimistic concurrency"
      exports: ["UserPrefsStore"]
    - path: "ui_service/src/hooks/useUserPrefs.ts"
      provides: "React hook for reading/writing user preferences"
      exports: ["useUserPrefs"]
  key_links:
    - from: "orchestrator/admin_api.py"
      to: "shared/auth/user_prefs.py"
      via: "GET/PUT /admin/user/prefs endpoints"
      pattern: "user.prefs"
    - from: "ui_service/src/hooks/useUserPrefs.ts"
      to: "ui_service/src/lib/adminClient.ts"
      via: "calls getUserPrefs/setUserPrefs"
      pattern: "adminApi\\.(get|set)UserPrefs"
---

<objective>
Add per-user preference persistence and fix fragility bugs across all pages.

Purpose: User selections (provider ordering, module favorites, theme, tab positions) are lost on page refresh. Error states (401s, invalid JSON, timeouts) fail silently or crash. This plan makes the UI sticky and resilient.

Output: User prefs SQLite store + API endpoints, useUserPrefs hook, error handling fixes across all pages, final verification checkpoint.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ui-contract-alignment/05-01-SUMMARY.md
@.planning/phases/05-ui-contract-alignment/05-02-SUMMARY.md
@.planning/phases/05-ui-contract-alignment/05-03-SUMMARY.md
@.planning/phases/05-ui-contract-alignment/05-04-SUMMARY.md

@shared/auth/api_keys.py
@orchestrator/admin_api.py
@ui_service/src/lib/adminClient.ts
@ui_service/src/lib/errors.ts
@ui_service/src/components/ui/error-states.tsx
@ui_service/src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: User preferences backend + frontend hook</name>
  <files>
    shared/auth/user_prefs.py
    orchestrator/admin_api.py
    ui_service/src/hooks/useUserPrefs.ts
    ui_service/src/lib/adminClient.ts
  </files>
  <action>
    **Backend** (`shared/auth/user_prefs.py`):
    - `UserPrefsStore` class with SQLite table `user_prefs`:
      - Columns: `user_id TEXT`, `org_id TEXT`, `prefs TEXT` (JSON), `version INTEGER`, `updated_at TEXT`
      - Primary key: `(user_id, org_id)`
    - Methods:
      - `get_prefs(user_id, org_id) -> dict | None`
      - `set_prefs(user_id, org_id, prefs: dict, expected_version: int) -> int` — returns new version; raises `ConcurrencyError` if `expected_version != current version`
    - WAL mode for concurrent access (same pattern as existing SQLite stores)
    - Default prefs schema: `{ theme: "dark", dashboard_layout: [], provider_order: [], module_favorites: [], monitoring_tab: 0 }`

    **Backend endpoints** (add to `orchestrator/admin_api.py`):
    - `GET /admin/user/prefs` — returns prefs JSON + version for authenticated user
    - `PUT /admin/user/prefs` — accepts `{ prefs: {...}, version: int }`, returns new version. Returns 409 if version mismatch (optimistic concurrency).
    - Both endpoints use `Depends(get_current_user)` for auth (user_id from API key)

    **Frontend hook** (`ui_service/src/hooks/useUserPrefs.ts`):
    - `useUserPrefs()` returns `{ prefs, isLoading, save, version }`
    - `save(updates)` merges updates into current prefs, POSTs to API with version
    - On 409 (conflict), refetch and retry once
    - Caches prefs in localStorage as fallback when API unavailable
    - Debounced save (500ms) to avoid excessive writes during rapid UI changes

    **Extend `adminClient.ts`** with:
    - `getUserPrefs(): Promise<{ prefs: UserPrefs, version: number }>`
    - `setUserPrefs(prefs: UserPrefs, version: number): Promise<{ version: number }>`

    **Wire into pages** (update each page to persist relevant prefs):
    - /monitoring: save `monitoring_tab` selection
    - /settings/providers: save `provider_order` (drag order, or just last-viewed)
    - /modules: save `module_favorites` (starred modules)
    - /capabilities: save `dashboard_layout` (filter preferences)

    **Tool usage note**: Backend work (user_prefs.py + admin_api.py) → **Cursor Pro**. Frontend hook → **Cursor Pro** (needs to understand adminClient pattern). No v0 needed for this task.
  </action>
  <verify>
    pytest tests/unit/test_user_prefs.py -q 2>/dev/null || echo "Tests not yet created"
    curl -s http://localhost:8003/admin/user/prefs | python -m json.tool | head -10
    grep -c "getUserPrefs" ui_service/src/lib/adminClient.ts
  </verify>
  <done>
    UserPrefsStore persists prefs in SQLite with optimistic concurrency.
    GET/PUT /admin/user/prefs endpoints work with auth.
    useUserPrefs hook provides prefs to UI components with debounced save.
    Page selections (tabs, favorites, filters) persist across sessions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Error resilience fixes + navigation updates</name>
  <files>
    ui_service/src/app/layout.tsx
    ui_service/src/components/nav/Navbar.tsx
  </files>
  <action>
    **Fix fragility bugs** (apply across all pages via shared patterns):

    1. **Context 401s → degraded state**: In `adminClient.ts` `adminFetch`, catch 401 responses and return a `NexusError` with code `NOT_AUTHORIZED` instead of throwing. Components using `useCapabilities` should show `DegradedBanner` with message "Authentication required — some features may be limited" instead of silently breaking.

    2. **"No valid JSON" responses → warning banner**: In `adminFetch`, wrap `res.json()` in try/catch. If JSON parse fails, throw `NexusError` with code `TOOL_SCHEMA_MISMATCH` and details including the raw text. UI should show warning banner: "Received unexpected response format from server".

    3. **High-latency responses → loading skeleton with timeout**: In `useCapabilities` hook, add a 10-second timeout. If fetch exceeds 10s, show `TimeoutSkeleton` with message "Server is taking longer than expected...". After 30s, show `DegradedBanner` with "Service may be unreachable".

    4. **Fix adminFetch to use AbortController** for request timeout (10s default, configurable).

    **Navigation updates** (update `Navbar.tsx` and `layout.tsx`):
    - Add nav links for new pages: /capabilities, /modules, /settings/providers
    - Keep existing links: /dashboard, /chat, /pipeline, /monitoring, /integrations, /settings, /finance
    - Add capability status indicator in navbar: small colored dot (green/yellow/red) that reflects overall system health from `useCapabilities().features`
    - Active page highlight in navbar

    **v0 component generation** (optional polish):
    ```
    "Generate shadcn/ui toast notification component for async status updates. Toast appears bottom-right, auto-dismisses after 5s. Variants: success (green), warning (yellow), error (red), info (blue). Shows icon + title + message. Queue multiple toasts vertically."
    ```

    If v0 generates a toast component, paste it as `ui_service/src/components/ui/toast.tsx` and wire it to error taxonomy from `errors.ts`. If you skip v0, use a simple div-based toast (no new dependencies).

    **Tool usage note**: All wiring work is **Cursor Pro** (multi-file edits to adminClient, hook, navbar, layout). Toast component visual from **v0** if desired.
  </action>
  <verify>
    npx tsc --noEmit --project ui_service/tsconfig.json 2>&1 | head -20
    grep -c "/capabilities" ui_service/src/components/nav/Navbar.tsx
    grep -c "AbortController" ui_service/src/lib/adminClient.ts
  </verify>
  <done>
    401 responses show degraded banner instead of silent failure.
    Invalid JSON responses show warning banner instead of blank page.
    High-latency responses show timeout skeleton after 10s.
    Navbar has links to all pages including new ones.
    System health indicator visible in navbar.
  </done>
</task>

<task type="checkpoint:human-verify">
  <name>Task 3: Full phase QA verification</name>
  <files>ui_service/src/app/capabilities/page.tsx</files>
  <action>
    Verify all 5 capability-driven pages render correctly against live orchestrator.
    Run `make verify` to confirm all 780+ tests still pass.
    Test error resilience by stopping the orchestrator and verifying degraded banners appear instead of blank screens.
    Test preference persistence by changing settings, refreshing the page, and confirming they persist.
  </action>
  <verify>
    1. Start the stack: `docker compose up` (or `make dev`)
    2. Visit each page:
       - `/capabilities` — feature cards with health status
       - `/modules` — module list with lifecycle actions
       - `/settings/providers` — provider list with lock/unlock
       - `/monitoring` — 3 tabs with real data
       - `/pipeline` — job list with SSE indicator
    3. Error resilience: stop orchestrator → degraded banners appear
    4. Preferences: change tab, refresh → persisted
    5. Tests: `make verify` passes
  </verify>
  <done>
    All 5 pages render correctly. Error resilience works. Preferences persist. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `pytest -q` — all existing tests pass (780+)
- `make verify` — full verification pipeline passes
- All 5 pages render from capability contract data
- Error states display correctly when backend is down
- User preferences persist across page refreshes
</verification>

<success_criteria>
- UI is capability-driven: every page renders from backend contract, not hardcoded assumptions
- Error handling is consistent and user-visible (no silent failures)
- User preferences persist across sessions via SQLite store
- Existing tests unbroken (zero regressions)
- Manual QA of all 5 pages against live orchestrator passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-ui-contract-alignment/05-05-SUMMARY.md`
</output>
