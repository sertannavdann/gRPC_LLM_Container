---
phase: 06-ux-visual-expansion
plan: 01
type: execute
wave: 1
depends_on: [05-03]
files_modified:
  - shared/contracts/__init__.py
  - shared/contracts/ui_capability_schema.py
  - orchestrator/admin_api.py
  - tests/unit/test_capability_contract.py
  - docs/ui_contract.md
  - ui_service/src/machines/nexusApp.ts
  - ui_service/src/hooks/useNexusApp.ts
  - ui_service/src/stores/nexusStore.ts
  - ui_service/package.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GET /admin/capabilities returns a typed CapabilityEnvelope with tools, modules, providers, adapters, features, config_version, timestamp"
    - "Adapters array in the envelope includes lock/unlock status from Phase 5 adapter registry"
    - "GET /admin/feature-health returns per-feature readiness with degraded reasons"
    - "GET /admin/config/version supports ETag for lightweight conditional polling"
    - "A feature is marked degraded if any installed adapter has isLocked() === true"
    - "Capability endpoint returns ETag header for If-None-Match conditional requests"
    - "XState v5 nexusAppMachine has three parallel regions: capability, dataSource, auth"
    - "ETag-based polling is managed by XState invoked actors, not setInterval"
    - "useNexusApp hook bridges XState to React components via useMachine"
    - "Zustand nexusStore bridges imperative triggers (chat tool calls) into XState events"
    - "npm packages installed: xstate, @xstate/react, recharts, framer-motion"
  artifacts:
    - path: "shared/contracts/ui_capability_schema.py"
      provides: "Pydantic models for CapabilityEnvelope, ToolCapability, ModuleCapability, ProviderCapability, AdapterCapability, FeatureHealth"
      exports: ["CapabilityEnvelope", "ToolCapability", "ModuleCapability", "ProviderCapability", "AdapterCapability", "FeatureHealth", "FeatureStatus"]
      min_lines: 80
    - path: "orchestrator/admin_api.py"
      provides: "Three BFF endpoints: GET /capabilities, GET /feature-health, GET /config/version, all with ETag support"
      min_lines: 50
    - path: "tests/unit/test_capability_contract.py"
      provides: "Contract tests for capability envelope structure, feature health derivation, ETag behavior"
      min_lines: 80
    - path: "docs/ui_contract.md"
      provides: "TypeScript type documentation for frontend consumption of capability endpoints"
      min_lines: 50
    - path: "ui_service/src/machines/nexusApp.ts"
      provides: "XState v5 root application statechart with parallel regions for capability polling, data source status, and auth"
      exports: ["nexusAppMachine"]
      min_lines: 80
    - path: "ui_service/src/hooks/useNexusApp.ts"
      provides: "React hook bridging nexusAppMachine to components via @xstate/react useMachine"
      exports: ["useNexusApp"]
      min_lines: 30
  key_links:
    - from: "orchestrator/admin_api.py"
      to: "shared/contracts/ui_capability_schema.py"
      via: "imports CapabilityEnvelope to serialize responses"
      pattern: "from shared\\.contracts\\.ui_capability_schema import"
    - from: "orchestrator/admin_api.py"
      to: "shared/modules/registry.py"
      via: "queries installed modules for capability envelope"
      pattern: "registry\\.(list|get)_modules"
    - from: "shared/contracts/ui_capability_schema.py"
      to: "shared/modules/validation_types.py"
      via: "uses ValidationResult from Phase 5 deduplication"
      pattern: "from shared\\.modules\\.validation_types import"
    - from: "ui_service/src/hooks/useNexusApp.ts"
      to: "ui_service/src/machines/nexusApp.ts"
      via: "imports nexusAppMachine for useMachine hook"
      pattern: "from.*machines/nexusApp"
    - from: "ui_service/src/machines/nexusApp.ts"
      to: "ui_service/src/lib/adminClient.ts"
      via: "invoked actors call adminClient for capability polling"
      pattern: "adminClient\\.getCapabilities"
    - from: "ui_service/src/stores/nexusStore.ts"
      to: "ui_service/src/machines/nexusApp.ts"
      via: "Zustand store bridges imperative events to XState send()"
      pattern: "xstateSend.*CAPABILITY_REFRESH"
---

<objective>
Create the backend capability contract and XState statechart infrastructure that all Phase 6 UI pages will build on.

Purpose: The UI currently hardcodes assumptions about available features, modules, and providers. This plan creates: (1) a single source of truth endpoint (`GET /admin/capabilities`) that the UI queries to determine what to render, and (2) an XState v5 root application statechart (nexusAppMachine) that manages capability polling, data source status, and auth as parallel state regions. This eliminates UI/backend desync and replaces scattered `useState` + `useEffect` patterns with a deterministic, visualizable state model.

Output: `CapabilityEnvelope` Pydantic model, three admin endpoints with ETag support, contract tests, TypeScript type documentation, XState root machine, useNexusApp hook, Zustand bridge, npm package installation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-minimal.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ux-visual-expansion/06-CONTEXT.md
@.planning/phases/05-refactoring/05-03-SUMMARY.md

Academic anchors:
- Event-Driven Microservice Orchestration Principles: §4.2 (CQRS — capability endpoint is the read-optimized query model, independent from service write paths), §6.1 (event-driven latency 1.2s vs 10-30s traditional)
- Agentic Builder-Tester Pattern: §5 (agent monitoring dashboards — feature-health derivation feeds monitoring page)
- Harel Statecharts: Parallel state regions, guards, invoked actors — implemented via XState v5 setup API

@orchestrator/admin_api.py
@shared/modules/registry.py
@shared/providers/
@ui_service/src/lib/adapter-lock/
@ui_service/src/lib/adminClient.ts
@ui_service/src/stores/nexusStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pydantic capability schema</name>
  <files>shared/contracts/__init__.py, shared/contracts/ui_capability_schema.py</files>
  <action>
    Create `shared/contracts/__init__.py` (empty, package marker).

    Create `shared/contracts/ui_capability_schema.py`:
    - `FeatureStatus` enum: `HEALTHY`, `DEGRADED`, `UNAVAILABLE`, `UNKNOWN`
    - `ToolCapability` model: `name: str`, `description: str`, `registered: bool`, `category: str` (builtin | custom)
    - `ModuleCapability` model: `id: str`, `name: str`, `category: str`, `platform: str`, `status: str` (installed | draft | disabled), `version: int | None`, `has_tests: bool`
    - `ProviderCapability` model: `id: str`, `name: str`, `tier: str` (standard | heavy | ultra), `locked: bool`, `connection_tested: bool`, `last_test_ok: bool | None`
    - `AdapterCapability` model (NEW for Phase 6): `id: str`, `name: str`, `category: str`, `locked: bool`, `missing_fields: list[str]`, `last_data_timestamp: str | None`, `connection_tested: bool`, `last_test_ok: bool | None`
    - `FeatureHealth` model: `feature: str`, `status: FeatureStatus`, `degraded_reasons: list[str]`, `dependencies: list[str]`
    - `CapabilityEnvelope` model: `tools: list[ToolCapability]`, `modules: list[ModuleCapability]`, `providers: list[ProviderCapability]`, `adapters: list[AdapterCapability]`, `features: list[FeatureHealth]`, `config_version: str`, `timestamp: str`
    - All models use `model_config = ConfigDict(from_attributes=True)` for ORM compatibility

    CQRS anchor (EDMO doc §4.2): This schema is the **query model** — a read-optimized projection of system state. The command side (module install, credential store, provider config) remains independent.
  </action>
  <verify>
    `python -c "from shared.contracts.ui_capability_schema import CapabilityEnvelope, AdapterCapability, FeatureHealth; print('ok')"` succeeds.
    `python -c "from shared.contracts.ui_capability_schema import CapabilityEnvelope; e = CapabilityEnvelope(tools=[], modules=[], providers=[], adapters=[], features=[], config_version='v1', timestamp='2026-01-01T00:00:00Z'); print(e.model_dump_json()[:50])"` — outputs valid JSON.
  </verify>
  <done>
    CapabilityEnvelope Pydantic model with tools, modules, providers, adapters, features, config_version, timestamp — all typed and serializable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Three BFF endpoints with ETag support</name>
  <files>orchestrator/admin_api.py</files>
  <action>
    Add three endpoints to `orchestrator/admin_api.py`:

    **GET /admin/capabilities**:
    - Queries: tool registry (registered tools), module registry (installed + draft modules), provider config (LLM providers + lock status), adapter registry (installed adapters + lock/unlock from Phase 5)
    - Assembles `CapabilityEnvelope` with all data
    - Computes ETag as SHA-256 of serialized envelope JSON
    - Returns 304 Not Modified if request `If-None-Match` header matches current ETag
    - Returns 200 with `ETag` response header otherwise
    - `config_version` derived from hash of current system configuration
    - `timestamp` is current UTC ISO 8601

    **GET /admin/feature-health**:
    - Derives per-feature health status:
      - `"modules"`: HEALTHY if all installed modules have status=installed, DEGRADED if any in draft/disabled state
      - `"providers"`: HEALTHY if at least one provider unlocked, DEGRADED if all locked
      - `"adapters"`: HEALTHY if no installed adapter has isLocked()==true, DEGRADED if any locked (with degraded_reasons listing which adapters are locked)
      - `"billing"`: HEALTHY if quota_manager reports capacity remaining, DEGRADED if usage > 80%
      - `"sandbox"`: HEALTHY if sandbox service reachable, UNAVAILABLE if connection fails
      - `"pipeline"`: HEALTHY if last build succeeded, DEGRADED if last build failed
    - Returns `list[FeatureHealth]`

    **GET /admin/config/version**:
    - Lightweight endpoint returning only `{ config_version: str, etag: str }`
    - Same ETag logic as /capabilities — clients poll this cheaply to detect changes, then fetch full /capabilities only on change

    All endpoints: require authentication (existing auth middleware), RBAC viewer+ access.
  </action>
  <verify>
    `grep -n "capabilities\|feature.health\|config/version" orchestrator/admin_api.py | wc -l` >= 3.
    `curl -s http://localhost:8003/admin/capabilities | python -m json.tool | head -5` — returns JSON with "tools", "modules" keys (when server running).
    `curl -s -H "If-None-Match: \"test\"" http://localhost:8003/admin/capabilities` — returns 200 (ETag mismatch).
  </verify>
  <done>
    Three BFF endpoints serving capability data with ETag-based conditional responses. Feature health includes adapter lock status from Phase 5.
  </done>
</task>

<task type="auto">
  <name>Task 3: Contract tests + TypeScript documentation</name>
  <files>tests/unit/test_capability_contract.py, docs/ui_contract.md</files>
  <action>
    Create `tests/unit/test_capability_contract.py`:
    - Test `CapabilityEnvelope` can be instantiated with all empty arrays -> valid
    - Test `CapabilityEnvelope` serializes to JSON with all expected keys
    - Test `AdapterCapability` with `locked=True` includes `missing_fields`
    - Test `FeatureHealth` with `status=DEGRADED` requires non-empty `degraded_reasons`
    - Test `ProviderCapability` with `locked=True` and `connection_tested=False`
    - Test `ModuleCapability` with all valid status values (installed, draft, disabled)
    - Test `ToolCapability` with builtin and custom categories
    - Test ETag generation is deterministic (same envelope -> same ETag)
    - Test ETag changes when capability data changes
    - Test feature health derivation: all adapters unlocked -> HEALTHY
    - Test feature health derivation: one adapter locked -> DEGRADED with reason
    - Test feature health derivation: no providers unlocked -> DEGRADED

    Create `docs/ui_contract.md`:
    - TypeScript interface definitions matching Pydantic models (for frontend dev reference)
    - Endpoint documentation: URL, method, headers (If-None-Match), response codes (200, 304, 401)
    - Polling pattern documentation: use /config/version for cheap polls, /capabilities for full fetch
    - XState integration notes: how nexusAppMachine invoked actors map to these endpoints
    - Feature health status meanings and degraded reason strings
    - Example responses for each endpoint
  </action>
  <verify>
    `python -m pytest tests/unit/test_capability_contract.py -v --tb=short` — all 12+ tests pass.
    `test -f docs/ui_contract.md && wc -l docs/ui_contract.md | awk '{print $1}'` >= 50.
  </verify>
  <done>
    12+ contract tests passing for all capability schema models. TypeScript type documentation for frontend consumption with endpoint specs, polling patterns, XState integration notes, and example responses.
  </done>
</task>

<task type="auto">
  <name>Task 4: npm package installation + XState root machine + useNexusApp hook</name>
  <files>ui_service/package.json, ui_service/src/machines/nexusApp.ts, ui_service/src/hooks/useNexusApp.ts, ui_service/src/stores/nexusStore.ts, ui_service/src/lib/adminClient.ts</files>
  <action>
    **Install npm packages** in ui_service:
    ```bash
    cd ui_service && pnpm add xstate@^5.18.0 @xstate/react@^4.1.0 recharts@^2.15.0 framer-motion@^11.15.0
    ```
    Note: @xyflow/react is already a NEXUS dependency — verify and upgrade to v12 if needed.

    **Create `ui_service/src/machines/nexusApp.ts`** — XState v5 root application statechart:
    - Uses XState v5 `setup()` API with full TypeScript typing
    - Context type: `{ envelope: CapabilityEnvelope | null, etag: string | null, error: NexusErrorType | null, userPrefs: UserPreferences | null }`
    - Events: `ENVELOPE_LOADED`, `ENVELOPE_NOT_MODIFIED`, `ENVELOPE_ERROR`, `CAPABILITY_REFRESH_REQUESTED`, `AUTH_EXPIRED`, `PREFS_LOADED`
    - Guards: `hasLiveAdapter` (any adapter unlocked), `allAdaptersLocked` (all locked), `isRetryableError` (TIMEOUT or DEGRADED_PROVIDER)
    - Invoked actors: `pollCapabilities` (fromPromise, calls adminClient.getCapabilities with ETag), `pollConfigVersion` (fromPromise, calls adminClient.getConfigVersion)
    - Three parallel state regions:
      1. **capability**: `loading -> current -> polling -> error` cycle. 30s polling interval via `after`. Auto-retry retryable errors after 5s.
      2. **dataSource**: `unknown -> live | mock | offline`. Derived from adapter lock states using guards. Transitions on ENVELOPE_LOADED.
      3. **auth**: `authenticated -> unauthenticated` on AUTH_EXPIRED.
    - All ETag-based polling managed by invoked actors (replaces setInterval)

    **Extend `ui_service/src/lib/adminClient.ts`**:
    - Add `getCapabilities(etag?: string): Promise<{ data: CapabilityEnvelope | null; etag: string; notModified: boolean }>` — sends `If-None-Match` header when etag provided. On 304 returns `{ data: null, etag, notModified: true }`. On 200 parses response, extracts ETag header.
    - Add `getFeatureHealth(): Promise<FeatureHealth[]>` — fetches from `GET /admin/feature-health`
    - Add `getConfigVersion(): Promise<{ config_version: string; etag: string }>` — lightweight polling endpoint
    - TypeScript types for `CapabilityEnvelope`, `AdapterCapability`, etc. matching docs/ui_contract.md

    **Create `ui_service/src/hooks/useNexusApp.ts`** — bridges XState to React:
    - Uses `useMachine` from `@xstate/react`
    - Returns: `{ envelope, isLoading, isError, error, isLive, isMock, isOffline, isAuthenticated, refresh }`
    - `isLive` = `state.matches('dataSource.live')`
    - `isMock` = `state.matches('dataSource.mock')`
    - `refresh()` = `send({ type: 'CAPABILITY_REFRESH_REQUESTED' })`
    - Registers XState send function with Zustand store on mount for cross-page event bridging

    **Update `ui_service/src/stores/nexusStore.ts`** — Zustand bridge:
    - Add `xstateSend: ((event: any) => void) | null` state
    - Add `setXStateSend(send)` action
    - Update `triggerCapabilityRefresh()` to dispatch via `xstateSend` instead of direct state mutation
    - This enables chat tool calls to trigger XState CAPABILITY_REFRESH_REQUESTED events
  </action>
  <verify>
    `cd ui_service && pnpm ls xstate @xstate/react recharts framer-motion` — all packages listed.
    `pnpm --filter ui_service build` — succeeds.
    `grep -n "nexusAppMachine\|setup\|createMachine" ui_service/src/machines/nexusApp.ts | wc -l` >= 3.
    `grep -n "useMachine\|useNexusApp" ui_service/src/hooks/useNexusApp.ts | wc -l` >= 2.
    `grep -n "xstateSend\|setXStateSend" ui_service/src/stores/nexusStore.ts | wc -l` >= 2.
  </verify>
  <done>
    npm packages installed. XState root machine with 3 parallel regions manages capability polling via invoked actors. useNexusApp hook provides typed state access. Zustand bridge enables cross-page XState event dispatch.
  </done>
</task>

</tasks>

<verification>
- `python -c "from shared.contracts.ui_capability_schema import CapabilityEnvelope"` succeeds
- `python -m pytest tests/unit/test_capability_contract.py -v` — all pass
- `grep -n "/admin/capabilities\|/admin/feature-health\|/admin/config/version" orchestrator/admin_api.py | wc -l` >= 3
- `test -f docs/ui_contract.md` — exists with 50+ lines
- `cd ui_service && pnpm ls xstate @xstate/react recharts framer-motion` — all listed
- `pnpm --filter ui_service build` — succeeds
- `grep -n "nexusAppMachine" ui_service/src/machines/nexusApp.ts` — machine exists with parallel regions
- `grep -n "useNexusApp" ui_service/src/hooks/useNexusApp.ts` — hook exports correctly
- `make test-self-evolution` — zero regressions
</verification>

<success_criteria>
- CapabilityEnvelope Pydantic model covers tools, modules, providers, adapters, features
- Adapters array includes lock/unlock status from Phase 5
- Three BFF endpoints with ETag conditional response support
- Feature health derivation correctly flags degraded adapters
- 12+ contract tests passing
- TypeScript documentation available for frontend development
- XState v5 nexusAppMachine manages capability polling via invoked actors (no setInterval)
- Parallel state regions for capability, dataSource, and auth
- useNexusApp hook replaces ad-hoc state management for all downstream pages
- Zustand bridge enables chat -> XState event dispatch
- All visualization toolkit npm packages installed and verified
</success_criteria>

<output>
After completion, create `.planning/phases/06-ux-visual-expansion/06-01-SUMMARY.md`
</output>
