---
phase: 06-ux-visual-expansion
plan: 01
type: execute
wave: 1
depends_on: [05-03]
files_modified:
  - shared/contracts/__init__.py
  - shared/contracts/ui_capability_schema.py
  - orchestrator/admin_api.py
  - tests/unit/test_capability_contract.py
  - docs/ui_contract.md
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GET /admin/capabilities returns a typed CapabilityEnvelope with tools, modules, providers, adapters, features, config_version, timestamp"
    - "Adapters array in the envelope includes lock/unlock status from Phase 5 adapter registry"
    - "GET /admin/feature-health returns per-feature readiness with degraded reasons"
    - "GET /admin/config/version supports ETag for lightweight conditional polling"
    - "A feature is marked degraded if any installed adapter has isLocked() === true"
    - "Capability endpoint returns ETag header for If-None-Match conditional requests"
  artifacts:
    - path: "shared/contracts/ui_capability_schema.py"
      provides: "Pydantic models for CapabilityEnvelope, ToolCapability, ModuleCapability, ProviderCapability, AdapterCapability, FeatureHealth"
      exports: ["CapabilityEnvelope", "ToolCapability", "ModuleCapability", "ProviderCapability", "AdapterCapability", "FeatureHealth", "FeatureStatus"]
      min_lines: 80
    - path: "orchestrator/admin_api.py"
      provides: "Three BFF endpoints: GET /capabilities, GET /feature-health, GET /config/version, all with ETag support"
      min_lines: 50
    - path: "tests/unit/test_capability_contract.py"
      provides: "Contract tests for capability envelope structure, feature health derivation, ETag behavior"
      min_lines: 80
    - path: "docs/ui_contract.md"
      provides: "TypeScript type documentation for frontend consumption of capability endpoints"
      min_lines: 50
  key_links:
    - from: "orchestrator/admin_api.py"
      to: "shared/contracts/ui_capability_schema.py"
      via: "imports CapabilityEnvelope to serialize responses"
      pattern: "from shared\\.contracts\\.ui_capability_schema import"
    - from: "orchestrator/admin_api.py"
      to: "shared/modules/registry.py"
      via: "queries installed modules for capability envelope"
      pattern: "registry\\.(list|get)_modules"
    - from: "shared/contracts/ui_capability_schema.py"
      to: "shared/modules/validation_types.py"
      via: "uses ValidationResult from Phase 5 deduplication"
      pattern: "from shared\\.modules\\.validation_types import"
---

<objective>
Create the backend capability contract — Pydantic schema + three BFF endpoints — that all Phase 6 UI pages will render from.

Purpose: The UI currently hardcodes assumptions about available features, modules, and providers. This plan creates a single source of truth endpoint (`GET /admin/capabilities`) that the UI queries to determine what to render. This eliminates UI/backend desync and makes every page contract-driven. The adapter lock/unlock status from Phase 5 (05-03) is included as a first-class citizen in the envelope.

Output: `CapabilityEnvelope` Pydantic model, three admin endpoints with ETag support, contract tests, TypeScript type documentation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-minimal.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ux-visual-expansion/06-CONTEXT.md
@.planning/phases/05-refactoring/05-03-SUMMARY.md

Academic anchors:
- Event-Driven Microservice Orchestration Principles: §4.2 (CQRS — capability endpoint is the read-optimized query model, independent from service write paths), §6.1 (event-driven latency 1.2s vs 10-30s traditional)
- Agentic Builder-Tester Pattern: §5 (agent monitoring dashboards — feature-health derivation feeds monitoring page)

@orchestrator/admin_api.py
@shared/modules/registry.py
@shared/providers/
@ui_service/src/lib/adapter-lock/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pydantic capability schema</name>
  <files>shared/contracts/__init__.py, shared/contracts/ui_capability_schema.py</files>
  <action>
    Create `shared/contracts/__init__.py` (empty, package marker).

    Create `shared/contracts/ui_capability_schema.py`:
    - `FeatureStatus` enum: `HEALTHY`, `DEGRADED`, `UNAVAILABLE`, `UNKNOWN`
    - `ToolCapability` model: `name: str`, `description: str`, `registered: bool`, `category: str` (builtin | custom)
    - `ModuleCapability` model: `id: str`, `name: str`, `category: str`, `platform: str`, `status: str` (installed | draft | disabled), `version: int | None`, `has_tests: bool`
    - `ProviderCapability` model: `id: str`, `name: str`, `tier: str` (standard | heavy | ultra), `locked: bool`, `connection_tested: bool`, `last_test_ok: bool | None`
    - `AdapterCapability` model (NEW for Phase 6): `id: str`, `name: str`, `category: str`, `locked: bool`, `missing_fields: list[str]`, `last_data_timestamp: str | None`, `connection_tested: bool`, `last_test_ok: bool | None`
    - `FeatureHealth` model: `feature: str`, `status: FeatureStatus`, `degraded_reasons: list[str]`, `dependencies: list[str]`
    - `CapabilityEnvelope` model: `tools: list[ToolCapability]`, `modules: list[ModuleCapability]`, `providers: list[ProviderCapability]`, `adapters: list[AdapterCapability]`, `features: list[FeatureHealth]`, `config_version: str`, `timestamp: str`
    - All models use `model_config = ConfigDict(from_attributes=True)` for ORM compatibility

    CQRS anchor (EDMO doc §4.2): This schema is the **query model** — a read-optimized projection of system state. The command side (module install, credential store, provider config) remains independent.
  </action>
  <verify>
    `python -c "from shared.contracts.ui_capability_schema import CapabilityEnvelope, AdapterCapability, FeatureHealth; print('ok')"` succeeds.
    `python -c "from shared.contracts.ui_capability_schema import CapabilityEnvelope; e = CapabilityEnvelope(tools=[], modules=[], providers=[], adapters=[], features=[], config_version='v1', timestamp='2026-01-01T00:00:00Z'); print(e.model_dump_json()[:50])"` — outputs valid JSON.
  </verify>
  <done>
    CapabilityEnvelope Pydantic model with tools, modules, providers, adapters, features, config_version, timestamp — all typed and serializable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Three BFF endpoints with ETag support</name>
  <files>orchestrator/admin_api.py</files>
  <action>
    Add three endpoints to `orchestrator/admin_api.py`:

    **GET /admin/capabilities**:
    - Queries: tool registry (registered tools), module registry (installed + draft modules), provider config (LLM providers + lock status), adapter registry (installed adapters + lock/unlock from Phase 5)
    - Assembles `CapabilityEnvelope` with all data
    - Computes ETag as SHA-256 of serialized envelope JSON
    - Returns 304 Not Modified if request `If-None-Match` header matches current ETag
    - Returns 200 with `ETag` response header otherwise
    - `config_version` derived from hash of current system configuration
    - `timestamp` is current UTC ISO 8601

    **GET /admin/feature-health**:
    - Derives per-feature health status:
      - `"modules"`: HEALTHY if all installed modules have status=installed, DEGRADED if any in draft/disabled state
      - `"providers"`: HEALTHY if at least one provider unlocked, DEGRADED if all locked
      - `"adapters"`: HEALTHY if no installed adapter has isLocked()==true, DEGRADED if any locked (with degraded_reasons listing which adapters are locked)
      - `"billing"`: HEALTHY if quota_manager reports capacity remaining, DEGRADED if usage > 80%
      - `"sandbox"`: HEALTHY if sandbox service reachable, UNAVAILABLE if connection fails
      - `"pipeline"`: HEALTHY if last build succeeded, DEGRADED if last build failed
    - Returns `list[FeatureHealth]`

    **GET /admin/config/version**:
    - Lightweight endpoint returning only `{ config_version: str, etag: str }`
    - Same ETag logic as /capabilities — clients poll this cheaply to detect changes, then fetch full /capabilities only on change

    All endpoints: require authentication (existing auth middleware), RBAC viewer+ access.
  </action>
  <verify>
    `grep -n "capabilities\|feature.health\|config/version" orchestrator/admin_api.py | wc -l` >= 3.
    `curl -s http://localhost:8003/admin/capabilities | python -m json.tool | head -5` — returns JSON with "tools", "modules" keys (when server running).
    `curl -s -H "If-None-Match: \"test\"" http://localhost:8003/admin/capabilities` — returns 200 (ETag mismatch).
  </verify>
  <done>
    Three BFF endpoints serving capability data with ETag-based conditional responses. Feature health includes adapter lock status from Phase 5.
  </done>
</task>

<task type="auto">
  <name>Task 3: Contract tests + TypeScript documentation</name>
  <files>tests/unit/test_capability_contract.py, docs/ui_contract.md</files>
  <action>
    Create `tests/unit/test_capability_contract.py`:
    - Test `CapabilityEnvelope` can be instantiated with all empty arrays → valid
    - Test `CapabilityEnvelope` serializes to JSON with all expected keys
    - Test `AdapterCapability` with `locked=True` includes `missing_fields`
    - Test `FeatureHealth` with `status=DEGRADED` requires non-empty `degraded_reasons`
    - Test `ProviderCapability` with `locked=True` and `connection_tested=False`
    - Test `ModuleCapability` with all valid status values (installed, draft, disabled)
    - Test `ToolCapability` with builtin and custom categories
    - Test ETag generation is deterministic (same envelope → same ETag)
    - Test ETag changes when capability data changes
    - Test feature health derivation: all adapters unlocked → HEALTHY
    - Test feature health derivation: one adapter locked → DEGRADED with reason
    - Test feature health derivation: no providers unlocked → DEGRADED

    Create `docs/ui_contract.md`:
    - TypeScript interface definitions matching Pydantic models (for frontend dev reference):
      ```typescript
      interface CapabilityEnvelope { tools: ToolCapability[]; modules: ModuleCapability[]; ... }
      ```
    - Endpoint documentation: URL, method, headers (If-None-Match), response codes (200, 304, 401)
    - Polling pattern documentation: use /config/version for cheap polls, /capabilities for full fetch
    - Feature health status meanings and degraded reason strings
    - Example responses for each endpoint
  </action>
  <verify>
    `python -m pytest tests/unit/test_capability_contract.py -v --tb=short` — all 12+ tests pass.
    `test -f docs/ui_contract.md && wc -l docs/ui_contract.md | awk '{print $1}'` >= 50.
  </verify>
  <done>
    12+ contract tests passing for all capability schema models. TypeScript type documentation for frontend consumption with endpoint specs, polling patterns, and example responses.
  </done>
</task>

</tasks>

<verification>
- `python -c "from shared.contracts.ui_capability_schema import CapabilityEnvelope"` succeeds
- `python -m pytest tests/unit/test_capability_contract.py -v` — all pass
- `grep -n "/admin/capabilities\|/admin/feature-health\|/admin/config/version" orchestrator/admin_api.py | wc -l` >= 3
- `test -f docs/ui_contract.md` — exists with 50+ lines
- `make test-self-evolution` — zero regressions
</verification>

<success_criteria>
- CapabilityEnvelope Pydantic model covers tools, modules, providers, adapters, features
- Adapters array includes lock/unlock status from Phase 5
- Three BFF endpoints with ETag conditional response support
- Feature health derivation correctly flags degraded adapters
- 12+ contract tests passing
- TypeScript documentation available for frontend development in Phase 6
</success_criteria>

<output>
After completion, create `.planning/phases/06-ux-visual-expansion/06-01-SUMMARY.md`
</output>
