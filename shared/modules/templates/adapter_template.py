"""
Adapter Code Generation Template.

Generates a BaseAdapter[T] subclass with @register_adapter decorator.
The template provides the complete structure â€” the LLM fills in the
API-specific fetch and transform logic using string interpolation.

Template variables:
    {module_name}        - e.g., "clashroyale"
    {category}           - e.g., "gaming"
    {platform}           - e.g., "clashroyale"
    {display_name}       - e.g., "Clash Royale Stats"
    {description}        - e.g., "Track player stats and battle logs"
    {icon}               - e.g., "ðŸŽ®"
    {class_name}         - e.g., "ClashRoyaleAdapter"
    {requires_auth}      - True or False
    {auth_type}          - "api_key", "oauth2", "basic", "none"
    {api_base_url}       - e.g., "https://api.clashroyale.com/v1"
    {data_format}        - "json" or "csv"
    {fetch_raw_body}     - LLM-generated fetch logic
    {transform_body}     - LLM-generated transform logic
    {capabilities_dict}  - Python dict literal for capabilities
"""

ADAPTER_TEMPLATE = '''"""
{display_name} Adapter

{description}

Auto-generated by NEXUS Executor Agent.
"""
import httpx
from datetime import datetime
from typing import Dict, Any, List

from shared.adapters.base import BaseAdapter, AdapterConfig
from shared.adapters.registry import register_adapter


API_BASE_URL = "{api_base_url}"


@register_adapter(
    category="{category}",
    platform="{platform}",
    display_name="{display_name}",
    description="{description}",
    icon="{icon}",
    requires_auth={requires_auth},
    auth_type="{auth_type}",
)
class {class_name}(BaseAdapter[Dict[str, Any]]):
    """
    {display_name} adapter.
    Fetches data from {api_base_url} and transforms to canonical format.
    """

    category = "{category}"
    platform = "{platform}"

    def __init__(self, config: AdapterConfig = None):
        super().__init__(config)
        self._api_base = API_BASE_URL
        self._timeout = httpx.Timeout(30.0)

    async def fetch_raw(self, config: AdapterConfig) -> Dict[str, Any]:
        """Fetch raw data from the {display_name} API."""
{fetch_raw_body}

    def transform(self, raw_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Transform raw API response to canonical format."""
{transform_body}

    def get_capabilities(self) -> Dict[str, bool]:
        return {capabilities_dict}
'''

# Default fetch body for API-key authenticated JSON APIs
DEFAULT_FETCH_BODY = '''        headers = {{}}
        if config and config.credentials:
            api_key = config.credentials.get("api_key", "")
            if api_key:
                headers["Authorization"] = f"Bearer {{api_key}}"

        async with httpx.AsyncClient(timeout=self._timeout) as client:
            response = await client.get(
                f"{{self._api_base}}/",
                headers=headers,
            )
            response.raise_for_status()
            return response.json()'''

# Default transform body
DEFAULT_TRANSFORM_BODY = '''        items = raw_data.get("items", raw_data.get("data", []))
        if not isinstance(items, list):
            items = [items] if items else []

        results = []
        for item in items:
            results.append({{
                "id": str(item.get("id", "")),
                "name": str(item.get("name", "")),
                "data": item,
                "fetched_at": datetime.utcnow().isoformat(),
                "platform": self.platform,
            }})
        return results'''

DEFAULT_CAPABILITIES = """{
            "read": True,
            "write": False,
            "real_time": False,
            "batch": True,
            "webhooks": False,
        }"""


def generate_adapter_code(
    module_name: str,
    category: str,
    platform: str,
    display_name: str = "",
    description: str = "",
    icon: str = "ðŸ”Œ",
    class_name: str = "",
    requires_auth: bool = True,
    auth_type: str = "api_key",
    api_base_url: str = "https://api.example.com/v1",
    data_format: str = "json",
    fetch_raw_body: str = "",
    transform_body: str = "",
    capabilities_dict: str = "",
) -> str:
    """
    Generate adapter source code from template.

    If fetch_raw_body / transform_body are empty, uses defaults.
    The LLM is expected to provide these for real integrations.
    """
    if not display_name:
        display_name = module_name.replace("_", " ").title()
    if not class_name:
        class_name = f"{platform.title().replace('_', '')}Adapter"
    if not fetch_raw_body:
        fetch_raw_body = DEFAULT_FETCH_BODY
    if not transform_body:
        transform_body = DEFAULT_TRANSFORM_BODY
    if not capabilities_dict:
        capabilities_dict = DEFAULT_CAPABILITIES

    return ADAPTER_TEMPLATE.format(
        module_name=module_name,
        category=category,
        platform=platform,
        display_name=display_name,
        description=description,
        icon=icon,
        class_name=class_name,
        requires_auth=requires_auth,
        auth_type=auth_type,
        api_base_url=api_base_url,
        data_format=data_format,
        fetch_raw_body=fetch_raw_body,
        transform_body=transform_body,
        capabilities_dict=capabilities_dict,
    )
