import { NextRequest, NextResponse } from 'next/server';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';
import { getProviderUnlockHandler } from '@/lib/provider-lock/providers';
import type { ProviderLockStatus } from '@/lib/provider-lock/base';

// Path to .env file in the root workspace
const ENV_PATH = process.env.ENV_FILE_PATH || '/app/.env';

interface EnvConfig {
  LLM_PROVIDER: string;
  LLM_PROVIDER_MODEL: string;
  NIM_API_KEY?: string;
  NIM_BASE_URL?: string;
  LLM_PROVIDER_TOP_P?: string;
  LLM_PROVIDER_THINKING?: string;
  LLM_PROVIDER_MAX_TOKENS?: string;
  PERPLEXITY_API_KEY?: string;
  OPENAI_API_KEY?: string;
  ANTHROPIC_API_KEY?: string;
  SERPER_API_KEY?: string;
  // LIDM delegation
  ENABLE_DELEGATION?: string;
  LIDM_HEAVY_MODEL?: string;
  LIDM_STANDARD_MODEL?: string;
  // Adapter keys
  OPENWEATHER_API_KEY?: string;
  OPENWEATHER_CITY?: string;
  GOOGLE_CALENDAR_CLIENT_ID?: string;
  GOOGLE_CALENDAR_CLIENT_SECRET?: string;
  GOOGLE_CALENDAR_ACCESS_TOKEN?: string;
  GOOGLE_CALENDAR_REFRESH_TOKEN?: string;
  CLASH_ROYALE_API_KEY?: string;
  CLASH_ROYALE_PLAYER_TAG?: string;
}

// Admin API for provider/model config (single source of truth)
const ADMIN_API = process.env.ADMIN_API_URL || 'http://orchestrator:8003';

function loadProviderConfigFallback(): {
  providers: Record<string, { models: string[]; default: string }>;
  lidmTierModels: Record<string, string[]>;
} {
  const candidatePaths = [
    process.env.ROUTING_CONFIG_PATH,
    '/app/config/routing_config.json',
    join(process.cwd(), 'config', 'routing_config.json'),
    join(process.cwd(), '..', 'config', 'routing_config.json'),
  ].filter((value): value is string => Boolean(value));

  for (const configPath of candidatePaths) {
    try {
      if (!existsSync(configPath)) {
        continue;
      }

      const raw = readFileSync(configPath, 'utf-8');
      const parsed = JSON.parse(raw);

      const providers = parsed?.providers;
      const lidmTierModels = parsed?.lidm_tier_models;

      if (providers && typeof providers === 'object') {
        return {
          providers,
          lidmTierModels: lidmTierModels && typeof lidmTierModels === 'object' ? lidmTierModels : {},
        };
      }
    } catch (error) {
      console.warn(`[Settings API] Failed reading fallback routing config at ${configPath}:`, (error as Error).message);
    }
  }

  return {
    providers: {
      local: {
        models: ['qwen2.5-3b-instruct-q5_k_m'],
        default: 'qwen2.5-3b-instruct-q5_k_m',
      },
    },
    lidmTierModels: {},
  };
}

async function fetchProviderConfig(): Promise<{
  providers: Record<string, { models: string[]; default: string }>;
  lidmTierModels: Record<string, string[]>;
}> {
  try {
    const res = await fetch(`${ADMIN_API}/admin/providers`, { cache: 'no-store' });
    if (!res.ok) throw new Error(`Admin API returned ${res.status}`);
    const data = await res.json();
    return {
      providers: data.providers || {},
      lidmTierModels: data.lidm_tier_models || {},
    };
  } catch (err) {
    console.warn('[Settings API] Admin API unreachable, using routing config fallback:', (err as Error).message);
    return loadProviderConfigFallback();
  }
}

function parseEnvFile(content: string): Record<string, string> {
  const result: Record<string, string> = {};
  const lines = content.split('\n');
  
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) continue;
    
    const key = trimmed.substring(0, eqIndex).trim();
    const value = trimmed.substring(eqIndex + 1).trim();
    result[key] = value;
  }
  
  return result;
}

function serializeEnvFile(config: Record<string, string>): string {
  const lines: string[] = [
    '# gRPC LLM Agent Framework - Environment Configuration',
    '# Auto-generated by UI settings',
    '',
  ];
  
  for (const [key, value] of Object.entries(config)) {
    if (value) {
      lines.push(`${key}=${value}`);
    }
  }
  
  return lines.join('\n') + '\n';
}

// GET - Read current settings
export async function GET() {
  try {
    let envConfig: Record<string, string> = {};

    if (existsSync(ENV_PATH)) {
      const content = readFileSync(ENV_PATH, 'utf-8');
      envConfig = parseEnvFile(content);
    }

    // Fetch provider/model config from admin API (single source of truth)
    const { providers: allProviders, lidmTierModels } = await fetchProviderConfig();

    const currentProvider = envConfig.LLM_PROVIDER || 'local';

    // Return full provider catalog so users can select/configure providers before adding keys.
    const availableProviders: Record<string, { models: string[]; default: string }> = {
      ...allProviders,
    };

    // If current provider is not in available list, fall back to 'local'
    const effectiveProvider = availableProviders[currentProvider] ? currentProvider : 'local';
    const effectiveModel = effectiveProvider === currentProvider
      ? envConfig.LLM_PROVIDER_MODEL || allProviders[currentProvider]?.default || ''
      : allProviders.local?.default || '';

    // Build provider lock metadata using unlock handler classes
    const providerLocks: Record<string, ProviderLockStatus> = {};
    for (const providerName of Object.keys(availableProviders)) {
      const handler = getProviderUnlockHandler(providerName);
      if (handler) {
        providerLocks[providerName] = handler.toStatus(envConfig);
      }
    }

    return NextResponse.json({
      config: {
        provider: effectiveProvider,
        model: effectiveModel,
        hasNimKey: !!envConfig.NIM_API_KEY,
        hasPerplexityKey: !!envConfig.PERPLEXITY_API_KEY,
        hasOpenaiKey: !!envConfig.OPENAI_API_KEY,
        hasAnthropicKey: !!envConfig.ANTHROPIC_API_KEY,
        hasSerperKey: !!envConfig.SERPER_API_KEY,
        // LIDM delegation
        delegationEnabled: (envConfig.ENABLE_DELEGATION || 'false').toLowerCase() === 'true',
        lidmHeavyModel: envConfig.LIDM_HEAVY_MODEL || 'Qwen2.5-14B-Instruct-Q4_K.gguf',
        lidmStandardModel: envConfig.LIDM_STANDARD_MODEL || 'qwen2.5-0.5b-instruct-q5_k_m.gguf',
      },
      providerLocks,
      lidmTierModels,
      adapters: {
        openweather: {
          hasApiKey: !!envConfig.OPENWEATHER_API_KEY,
          city: envConfig.OPENWEATHER_CITY || 'Toronto,CA',
        },
        google_calendar: {
          hasClientId: !!envConfig.GOOGLE_CALENDAR_CLIENT_ID,
          hasClientSecret: !!envConfig.GOOGLE_CALENDAR_CLIENT_SECRET,
          hasAccessToken: !!envConfig.GOOGLE_CALENDAR_ACCESS_TOKEN,
          hasRefreshToken: !!envConfig.GOOGLE_CALENDAR_REFRESH_TOKEN,
          connected: !!(envConfig.GOOGLE_CALENDAR_ACCESS_TOKEN && envConfig.GOOGLE_CALENDAR_REFRESH_TOKEN),
        },
        clashroyale: {
          hasApiKey: !!envConfig.CLASH_ROYALE_API_KEY,
          playerTag: envConfig.CLASH_ROYALE_PLAYER_TAG || '',
        },
      },
      providers: availableProviders,
    });
  } catch (error: any) {
    console.error('[Settings API] GET error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to read settings' },
      { status: 500 }
    );
  }
}

// POST - Update settings
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { provider, model, apiKeys, adapterKeys, delegation } = body;

    // Read existing config
    let envConfig: Record<string, string> = {};
    if (existsSync(ENV_PATH)) {
      const content = readFileSync(ENV_PATH, 'utf-8');
      envConfig = parseEnvFile(content);
    }

    // Update provider and model
    if (provider) {
      envConfig.LLM_PROVIDER = provider;
    }
    if (model) {
      envConfig.LLM_PROVIDER_MODEL = model;
    }

    // Update LIDM delegation settings
    if (delegation !== undefined) {
      envConfig.ENABLE_DELEGATION = delegation.enabled ? 'true' : 'false';
      if (delegation.heavyModel) envConfig.LIDM_HEAVY_MODEL = delegation.heavyModel;
      if (delegation.standardModel) envConfig.LIDM_STANDARD_MODEL = delegation.standardModel;
    }

    // Update LLM API keys (only if provided - don't overwrite with empty)
    if (apiKeys) {
      if (apiKeys.nvidia) envConfig.NIM_API_KEY = apiKeys.nvidia;
      if (apiKeys.perplexity) envConfig.PERPLEXITY_API_KEY = apiKeys.perplexity;
      if (apiKeys.openai) envConfig.OPENAI_API_KEY = apiKeys.openai;
      if (apiKeys.anthropic) envConfig.ANTHROPIC_API_KEY = apiKeys.anthropic;
      if (apiKeys.serper) envConfig.SERPER_API_KEY = apiKeys.serper;
    }

    // Set sensible NVIDIA defaults when provider is selected
    if (provider === 'nvidia') {
      envConfig.NIM_BASE_URL = envConfig.NIM_BASE_URL || 'https://integrate.api.nvidia.com/v1';
      envConfig.LLM_PROVIDER_TOP_P = envConfig.LLM_PROVIDER_TOP_P || '0.95';
      envConfig.LLM_PROVIDER_THINKING = envConfig.LLM_PROVIDER_THINKING || 'true';
      envConfig.LLM_PROVIDER_MAX_TOKENS = envConfig.LLM_PROVIDER_MAX_TOKENS || '16384';
    }

    // Update adapter keys (only non-empty values)
    if (adapterKeys) {
      const adapterKeyMap: Record<string, string> = {
        OPENWEATHER_API_KEY: adapterKeys.openweatherApiKey,
        OPENWEATHER_CITY: adapterKeys.openweatherCity,
        GOOGLE_CALENDAR_CLIENT_ID: adapterKeys.googleCalendarClientId,
        GOOGLE_CALENDAR_CLIENT_SECRET: adapterKeys.googleCalendarClientSecret,
        GOOGLE_CALENDAR_ACCESS_TOKEN: adapterKeys.googleCalendarAccessToken,
        GOOGLE_CALENDAR_REFRESH_TOKEN: adapterKeys.googleCalendarRefreshToken,
        CLASH_ROYALE_API_KEY: adapterKeys.clashroyaleApiKey,
        CLASH_ROYALE_PLAYER_TAG: adapterKeys.clashroyalePlayerTag,
      };

      for (const [envKey, value] of Object.entries(adapterKeyMap)) {
        if (value !== undefined && value !== '') {
          envConfig[envKey] = value as string;
        }
      }
    }

    // Write back to file
    const content = serializeEnvFile(envConfig);
    writeFileSync(ENV_PATH, content, 'utf-8');

    const updatedItems = [provider && 'provider', model && 'model', apiKeys && 'apiKeys', adapterKeys && 'adapterKeys'].filter(Boolean);
    console.log(`[Settings API] Updated: ${updatedItems.join(', ')}`);

    return NextResponse.json({
      success: true,
      message: 'Settings saved. Restart services to apply changes.',
      restartRequired: true,
    });
  } catch (error: any) {
    console.error('[Settings API] POST error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to save settings' },
      { status: 500 }
    );
  }
}
