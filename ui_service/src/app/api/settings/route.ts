import { NextRequest, NextResponse } from 'next/server';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';
import { getProviderUnlockHandler } from '@/lib/provider-lock/providers';
import { getAdapterLockHandler } from '@/lib/adapter-lock/adapters';
import type { ProviderLockStatus } from '@/lib/provider-lock/base';

// Path to .env file — used for provider/LLM infrastructure config only
const ENV_PATH = process.env.ENV_FILE_PATH || '/app/.env';

interface EnvConfig {
  LLM_PROVIDER: string;
  LLM_PROVIDER_MODEL: string;
  NIM_API_KEY?: string;
  NIM_BASE_URL?: string;
  LLM_PROVIDER_TOP_P?: string;
  LLM_PROVIDER_THINKING?: string;
  LLM_PROVIDER_MAX_TOKENS?: string;
  PERPLEXITY_API_KEY?: string;
  OPENAI_API_KEY?: string;
  ANTHROPIC_API_KEY?: string;
  SERPER_API_KEY?: string;
  // LIDM delegation
  ENABLE_DELEGATION?: string;
  LIDM_HEAVY_MODEL?: string;
  LIDM_STANDARD_MODEL?: string;
  // Note: Adapter keys no longer stored in .env — they flow through Admin API
}

// Admin API for provider/model config (single source of truth)
const ADMIN_API = process.env.ADMIN_API_URL || 'http://orchestrator:8003';

const DEFAULT_PROVIDER_CATALOG: Record<string, { models: string[]; default: string }> = {
  local: {
    models: [
      'qwen2.5-3b-instruct-q5_k_m',
      'Qwen2.5-14B-Instruct-Q4_K',
      'Mistral-Small-24B-Instruct-2501.Q8_0',
      'qwen2.5-0.5b-instruct-q5_k_m',
    ],
    default: 'qwen2.5-3b-instruct-q5_k_m',
  },
  perplexity: {
    models: ['sonar-pro', 'sonar', 'sonar-deep-research'],
    default: 'sonar-pro',
  },
  openai: {
    models: ['gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo', 'gpt-3.5-turbo'],
    default: 'gpt-4o-mini',
  },
  nvidia: {
    models: ['moonshotai/kimi-k2.5'],
    default: 'moonshotai/kimi-k2.5',
  },
  anthropic: {
    models: ['claude-3-5-sonnet-20241022', 'claude-3-opus-20240229', 'claude-3-haiku-20240307'],
    default: 'claude-3-5-sonnet-20241022',
  },
};

const DEFAULT_LIDM_TIER_MODELS: Record<string, string[]> = {
  heavy: ['Qwen2.5-14B-Instruct-Q4_K.gguf', 'Mistral-Small-24B-Instruct-2501.Q8_0.gguf'],
  standard: ['qwen2.5-0.5b-instruct-q5_k_m.gguf'],
};

function loadProviderConfigFallback(): {
  providers: Record<string, { models: string[]; default: string }>;
  lidmTierModels: Record<string, string[]>;
} {
  const candidatePaths = [
    process.env.ROUTING_CONFIG_PATH,
    '/app/config/routing_config.json',
    join(process.cwd(), 'config', 'routing_config.json'),
    join(process.cwd(), '..', 'config', 'routing_config.json'),
  ].filter((value): value is string => Boolean(value));

  for (const configPath of candidatePaths) {
    try {
      if (!existsSync(configPath)) {
        continue;
      }

      const raw = readFileSync(configPath, 'utf-8');
      const parsed = JSON.parse(raw);

      const providers = parsed?.providers;
      const lidmTierModels = parsed?.lidm_tier_models;

      if (providers && typeof providers === 'object') {
        return {
          providers: {
            ...DEFAULT_PROVIDER_CATALOG,
            ...providers,
          },
          lidmTierModels:
            lidmTierModels && typeof lidmTierModels === 'object'
              ? { ...DEFAULT_LIDM_TIER_MODELS, ...lidmTierModels }
              : DEFAULT_LIDM_TIER_MODELS,
        };
      }
    } catch (error) {
      console.warn(`[Settings API] Failed reading fallback routing config at ${configPath}:`, (error as Error).message);
    }
  }

  return {
    providers: DEFAULT_PROVIDER_CATALOG,
    lidmTierModels: DEFAULT_LIDM_TIER_MODELS,
  };
}

async function fetchProviderConfig(): Promise<{
  providers: Record<string, { models: string[]; default: string }>;
  lidmTierModels: Record<string, string[]>;
}> {
  try {
    const res = await fetch(`${ADMIN_API}/admin/providers`, { cache: 'no-store' });
    if (!res.ok) throw new Error(`Admin API returned ${res.status}`);
    const data = await res.json();
    return {
      providers: data.providers || {},
      lidmTierModels: data.lidm_tier_models || {},
    };
  } catch (err) {
    console.warn('[Settings API] Admin API unreachable, using routing config fallback:', (err as Error).message);
    return loadProviderConfigFallback();
  }
}

function parseEnvFile(content: string): Record<string, string> {
  const result: Record<string, string> = {};
  const lines = content.split('\n');
  
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) continue;
    
    const key = trimmed.substring(0, eqIndex).trim();
    const value = trimmed.substring(eqIndex + 1).trim();
    result[key] = value;
  }
  
  return result;
}

function serializeEnvFile(config: Record<string, string>): string {
  const lines: string[] = [
    '# gRPC LLM Agent Framework - Environment Configuration',
    '# Auto-generated by UI settings',
    '',
  ];
  
  for (const [key, value] of Object.entries(config)) {
    if (value) {
      lines.push(`${key}=${value}`);
    }
  }
  
  return lines.join('\n') + '\n';
}

/**
 * Fetch adapter credential status from Admin API via adapter-lock handlers.
 * Replaces direct .env reading for adapter keys.
 */
async function getAdapterStatusFromAdminAPI() {
  const adapters: Record<string, Record<string, unknown>> = {
    openweather: { hasApiKey: false, city: 'Toronto,CA' },
    google_calendar: { hasClientId: false, hasClientSecret: false, hasAccessToken: false, hasRefreshToken: false, connected: false },
    clashroyale: { hasApiKey: false, playerTag: '' },
  };

  try {
    const weatherHandler = getAdapterLockHandler('weather/openweather');
    if (weatherHandler) {
      const creds = await weatherHandler.fetchCredentials();
      adapters.openweather = {
        hasApiKey: !!creds.api_key,
        city: (creds.base_url as string) || 'Toronto,CA',
      };
    }

    const calendarHandler = getAdapterLockHandler('calendar/google_calendar');
    if (calendarHandler) {
      const creds = await calendarHandler.fetchCredentials();
      adapters.google_calendar = {
        hasClientId: !!creds.client_id,
        hasClientSecret: !!creds.client_secret,
        hasAccessToken: !!creds.oauth_token,
        hasRefreshToken: !!creds.refresh_token,
        connected: !!(creds.oauth_token && creds.refresh_token),
      };
    }

    const gamingHandler = getAdapterLockHandler('gaming/clashroyale');
    if (gamingHandler) {
      const creds = await gamingHandler.fetchCredentials();
      adapters.clashroyale = {
        hasApiKey: !!creds.api_key,
        playerTag: (creds.player_tag as string) || '',
      };
    }
  } catch (err) {
    console.warn('[Settings API] Failed to fetch adapter status from Admin API:', (err as Error).message);
  }

  return adapters;
}

/**
 * Store adapter credentials via Admin API credential store.
 * Maps UI field names to adapter-lock credential keys.
 */
async function storeAdapterKeysViaAdminAPI(adapterKeys: Record<string, string | undefined>) {
  // Weather adapter
  const weatherCreds: Record<string, string> = {};
  if (adapterKeys.openweatherApiKey) weatherCreds.api_key = adapterKeys.openweatherApiKey;
  if (adapterKeys.openweatherCity) weatherCreds.base_url = adapterKeys.openweatherCity;
  if (Object.keys(weatherCreds).length > 0) {
    const handler = getAdapterLockHandler('weather/openweather');
    if (handler) await handler.storeCredentials(weatherCreds);
  }

  // Calendar adapter
  const calendarCreds: Record<string, string> = {};
  if (adapterKeys.googleCalendarClientId) calendarCreds.client_id = adapterKeys.googleCalendarClientId;
  if (adapterKeys.googleCalendarClientSecret) calendarCreds.client_secret = adapterKeys.googleCalendarClientSecret;
  if (adapterKeys.googleCalendarAccessToken) calendarCreds.oauth_token = adapterKeys.googleCalendarAccessToken;
  if (adapterKeys.googleCalendarRefreshToken) calendarCreds.refresh_token = adapterKeys.googleCalendarRefreshToken;
  if (Object.keys(calendarCreds).length > 0) {
    const handler = getAdapterLockHandler('calendar/google_calendar');
    if (handler) await handler.storeCredentials(calendarCreds);
  }

  // Gaming adapter
  const gamingCreds: Record<string, string> = {};
  if (adapterKeys.clashroyaleApiKey) gamingCreds.api_key = adapterKeys.clashroyaleApiKey;
  if (adapterKeys.clashroyalePlayerTag) gamingCreds.player_tag = adapterKeys.clashroyalePlayerTag;
  if (Object.keys(gamingCreds).length > 0) {
    const handler = getAdapterLockHandler('gaming/clashroyale');
    if (handler) await handler.storeCredentials(gamingCreds);
  }
}

// GET - Read current settings
export async function GET() {
  try {
    let envConfig: Record<string, string> = {};

    if (existsSync(ENV_PATH)) {
      const content = readFileSync(ENV_PATH, 'utf-8');
      envConfig = parseEnvFile(content);
    }

    // Fetch provider/model config from admin API (single source of truth)
    const { providers: allProviders, lidmTierModels } = await fetchProviderConfig();

    const currentProvider = envConfig.LLM_PROVIDER || 'local';

    // Return full provider catalog so users can select/configure providers before adding keys.
    const availableProviders: Record<string, { models: string[]; default: string }> = {
      ...allProviders,
    };

    // If current provider is not in available list, fall back to 'local'
    const effectiveProvider = availableProviders[currentProvider] ? currentProvider : 'local';
    const effectiveModel = effectiveProvider === currentProvider
      ? envConfig.LLM_PROVIDER_MODEL || allProviders[currentProvider]?.default || ''
      : allProviders.local?.default || '';

    // Build provider lock metadata using unlock handler classes
    const providerLocks: Record<string, ProviderLockStatus> = {};
    for (const providerName of Object.keys(availableProviders)) {
      const handler = getProviderUnlockHandler(providerName);
      if (handler) {
        providerLocks[providerName] = handler.toStatus(envConfig);
      }
    }

    return NextResponse.json({
      config: {
        provider: effectiveProvider,
        model: effectiveModel,
        hasNimKey: !!envConfig.NIM_API_KEY,
        hasPerplexityKey: !!envConfig.PERPLEXITY_API_KEY,
        hasOpenaiKey: !!envConfig.OPENAI_API_KEY,
        hasAnthropicKey: !!envConfig.ANTHROPIC_API_KEY,
        hasSerperKey: !!envConfig.SERPER_API_KEY,
        // LIDM delegation
        delegationEnabled: (envConfig.ENABLE_DELEGATION || 'false').toLowerCase() === 'true',
        lidmHeavyModel: envConfig.LIDM_HEAVY_MODEL || 'Qwen2.5-14B-Instruct-Q4_K.gguf',
        lidmStandardModel: envConfig.LIDM_STANDARD_MODEL || 'qwen2.5-0.5b-instruct-q5_k_m.gguf',
      },
      providerLocks,
      lidmTierModels,
      adapters: await getAdapterStatusFromAdminAPI(),
      providers: availableProviders,
    });
  } catch (error: any) {
    console.error('[Settings API] GET error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to read settings' },
      { status: 500 }
    );
  }
}

// POST - Update settings
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { provider, model, apiKeys, adapterKeys, delegation } = body;

    // Read existing config
    let envConfig: Record<string, string> = {};
    if (existsSync(ENV_PATH)) {
      const content = readFileSync(ENV_PATH, 'utf-8');
      envConfig = parseEnvFile(content);
    }

    // Update provider and model
    if (provider) {
      envConfig.LLM_PROVIDER = provider;
    }
    if (model) {
      envConfig.LLM_PROVIDER_MODEL = model;
    }

    // Update LIDM delegation settings
    if (delegation !== undefined) {
      envConfig.ENABLE_DELEGATION = delegation.enabled ? 'true' : 'false';
      if (delegation.heavyModel) envConfig.LIDM_HEAVY_MODEL = delegation.heavyModel;
      if (delegation.standardModel) envConfig.LIDM_STANDARD_MODEL = delegation.standardModel;
    }

    // Update LLM API keys (only if provided - don't overwrite with empty)
    if (apiKeys) {
      if (apiKeys.nvidia) envConfig.NIM_API_KEY = apiKeys.nvidia;
      if (apiKeys.perplexity) envConfig.PERPLEXITY_API_KEY = apiKeys.perplexity;
      if (apiKeys.openai) envConfig.OPENAI_API_KEY = apiKeys.openai;
      if (apiKeys.anthropic) envConfig.ANTHROPIC_API_KEY = apiKeys.anthropic;
      if (apiKeys.serper) envConfig.SERPER_API_KEY = apiKeys.serper;
    }

    // Set sensible NVIDIA defaults when provider is selected
    if (provider === 'nvidia') {
      envConfig.NIM_BASE_URL = envConfig.NIM_BASE_URL || 'https://integrate.api.nvidia.com/v1';
      envConfig.LLM_PROVIDER_TOP_P = envConfig.LLM_PROVIDER_TOP_P || '0.95';
      envConfig.LLM_PROVIDER_THINKING = envConfig.LLM_PROVIDER_THINKING || 'true';
      envConfig.LLM_PROVIDER_MAX_TOKENS = envConfig.LLM_PROVIDER_MAX_TOKENS || '16384';
    }

    // Update adapter keys via Admin API credential store (not .env)
    if (adapterKeys) {
      await storeAdapterKeysViaAdminAPI(adapterKeys);
    }

    // Write provider/LLM config back to .env (infrastructure config only, no adapter keys)
    const content = serializeEnvFile(envConfig);
    writeFileSync(ENV_PATH, content, 'utf-8');

    const updatedItems = [provider && 'provider', model && 'model', apiKeys && 'apiKeys', adapterKeys && 'adapterKeys'].filter(Boolean);
    console.log(`[Settings API] Updated: ${updatedItems.join(', ')}`);

    return NextResponse.json({
      success: true,
      message: 'Settings saved. Restart services to apply changes.',
      restartRequired: true,
    });
  } catch (error: any) {
    console.error('[Settings API] POST error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to save settings' },
      { status: 500 }
    );
  }
}
