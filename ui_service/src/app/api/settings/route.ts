import { NextRequest, NextResponse } from 'next/server';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';

// Path to .env file in the root workspace
const ENV_PATH = process.env.ENV_FILE_PATH || '/app/.env';

interface EnvConfig {
  LLM_PROVIDER: string;
  LLM_PROVIDER_MODEL: string;
  PERPLEXITY_API_KEY?: string;
  OPENAI_API_KEY?: string;
  ANTHROPIC_API_KEY?: string;
  SERPER_API_KEY?: string;
  // LIDM delegation
  ENABLE_DELEGATION?: string;
  LIDM_HEAVY_MODEL?: string;
  LIDM_STANDARD_MODEL?: string;
  // Adapter keys
  OPENWEATHER_API_KEY?: string;
  OPENWEATHER_CITY?: string;
  GOOGLE_CALENDAR_CLIENT_ID?: string;
  GOOGLE_CALENDAR_CLIENT_SECRET?: string;
  GOOGLE_CALENDAR_ACCESS_TOKEN?: string;
  GOOGLE_CALENDAR_REFRESH_TOKEN?: string;
  CLASH_ROYALE_API_KEY?: string;
  CLASH_ROYALE_PLAYER_TAG?: string;
}

// Admin API for provider/model config (single source of truth)
const ADMIN_API = process.env.ADMIN_API_URL || 'http://orchestrator:8003';

async function fetchProviderConfig(): Promise<{
  providers: Record<string, { models: string[]; default: string }>;
  lidmTierModels: Record<string, string[]>;
}> {
  try {
    const res = await fetch(`${ADMIN_API}/admin/providers`, { next: { revalidate: 30 } });
    if (!res.ok) throw new Error(`Admin API returned ${res.status}`);
    const data = await res.json();
    return {
      providers: data.providers || {},
      lidmTierModels: data.lidm_tier_models || {},
    };
  } catch (err) {
    console.warn('[Settings API] Admin API unreachable, using empty defaults:', (err as Error).message);
    return { providers: { local: { models: [], default: '' } }, lidmTierModels: {} };
  }
}

function parseEnvFile(content: string): Record<string, string> {
  const result: Record<string, string> = {};
  const lines = content.split('\n');
  
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) continue;
    
    const key = trimmed.substring(0, eqIndex).trim();
    const value = trimmed.substring(eqIndex + 1).trim();
    result[key] = value;
  }
  
  return result;
}

function serializeEnvFile(config: Record<string, string>): string {
  const lines: string[] = [
    '# gRPC LLM Agent Framework - Environment Configuration',
    '# Auto-generated by UI settings',
    '',
  ];
  
  for (const [key, value] of Object.entries(config)) {
    if (value) {
      lines.push(`${key}=${value}`);
    }
  }
  
  return lines.join('\n') + '\n';
}

// GET - Read current settings
export async function GET() {
  try {
    let envConfig: Record<string, string> = {};

    if (existsSync(ENV_PATH)) {
      const content = readFileSync(ENV_PATH, 'utf-8');
      envConfig = parseEnvFile(content);
    }

    // Fetch provider/model config from admin API (single source of truth)
    const { providers: allProviders, lidmTierModels } = await fetchProviderConfig();

    const currentProvider = envConfig.LLM_PROVIDER || 'local';

    // Filter providers: always include 'local', only include cloud providers with API keys
    const providerKeyMap: Record<string, string> = {
      perplexity: 'PERPLEXITY_API_KEY',
      openai: 'OPENAI_API_KEY',
      anthropic: 'ANTHROPIC_API_KEY',
    };

    const availableProviders: Record<string, { models: string[]; default: string }> = {};
    for (const [name, info] of Object.entries(allProviders)) {
      if (name === 'local' || envConfig[providerKeyMap[name]]) {
        availableProviders[name] = info;
      }
    }

    // If current provider is not in available list, fall back to 'local'
    const effectiveProvider = availableProviders[currentProvider] ? currentProvider : 'local';
    const effectiveModel = effectiveProvider === currentProvider
      ? envConfig.LLM_PROVIDER_MODEL || allProviders[currentProvider]?.default || ''
      : allProviders.local?.default || '';

    return NextResponse.json({
      config: {
        provider: effectiveProvider,
        model: effectiveModel,
        hasPerplexityKey: !!envConfig.PERPLEXITY_API_KEY,
        hasOpenaiKey: !!envConfig.OPENAI_API_KEY,
        hasAnthropicKey: !!envConfig.ANTHROPIC_API_KEY,
        hasSerperKey: !!envConfig.SERPER_API_KEY,
        // LIDM delegation
        delegationEnabled: (envConfig.ENABLE_DELEGATION || 'false').toLowerCase() === 'true',
        lidmHeavyModel: envConfig.LIDM_HEAVY_MODEL || 'Qwen2.5-14B-Instruct-Q4_K.gguf',
        lidmStandardModel: envConfig.LIDM_STANDARD_MODEL || 'qwen2.5-0.5b-instruct-q5_k_m.gguf',
      },
      lidmTierModels,
      adapters: {
        openweather: {
          hasApiKey: !!envConfig.OPENWEATHER_API_KEY,
          city: envConfig.OPENWEATHER_CITY || 'Toronto,CA',
        },
        google_calendar: {
          hasClientId: !!envConfig.GOOGLE_CALENDAR_CLIENT_ID,
          hasClientSecret: !!envConfig.GOOGLE_CALENDAR_CLIENT_SECRET,
          hasAccessToken: !!envConfig.GOOGLE_CALENDAR_ACCESS_TOKEN,
          hasRefreshToken: !!envConfig.GOOGLE_CALENDAR_REFRESH_TOKEN,
          connected: !!(envConfig.GOOGLE_CALENDAR_ACCESS_TOKEN && envConfig.GOOGLE_CALENDAR_REFRESH_TOKEN),
        },
        clashroyale: {
          hasApiKey: !!envConfig.CLASH_ROYALE_API_KEY,
          playerTag: envConfig.CLASH_ROYALE_PLAYER_TAG || '',
        },
      },
      providers: availableProviders,
    });
  } catch (error: any) {
    console.error('[Settings API] GET error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to read settings' },
      { status: 500 }
    );
  }
}

// POST - Update settings
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { provider, model, apiKeys, adapterKeys, delegation } = body;

    // Read existing config
    let envConfig: Record<string, string> = {};
    if (existsSync(ENV_PATH)) {
      const content = readFileSync(ENV_PATH, 'utf-8');
      envConfig = parseEnvFile(content);
    }

    // Update provider and model
    if (provider) {
      envConfig.LLM_PROVIDER = provider;
    }
    if (model) {
      envConfig.LLM_PROVIDER_MODEL = model;
    }

    // Update LIDM delegation settings
    if (delegation !== undefined) {
      envConfig.ENABLE_DELEGATION = delegation.enabled ? 'true' : 'false';
      if (delegation.heavyModel) envConfig.LIDM_HEAVY_MODEL = delegation.heavyModel;
      if (delegation.standardModel) envConfig.LIDM_STANDARD_MODEL = delegation.standardModel;
    }

    // Update LLM API keys (only if provided - don't overwrite with empty)
    if (apiKeys) {
      if (apiKeys.perplexity) envConfig.PERPLEXITY_API_KEY = apiKeys.perplexity;
      if (apiKeys.openai) envConfig.OPENAI_API_KEY = apiKeys.openai;
      if (apiKeys.anthropic) envConfig.ANTHROPIC_API_KEY = apiKeys.anthropic;
      if (apiKeys.serper) envConfig.SERPER_API_KEY = apiKeys.serper;
    }

    // Update adapter keys (only non-empty values)
    if (adapterKeys) {
      const adapterKeyMap: Record<string, string> = {
        OPENWEATHER_API_KEY: adapterKeys.openweatherApiKey,
        OPENWEATHER_CITY: adapterKeys.openweatherCity,
        GOOGLE_CALENDAR_CLIENT_ID: adapterKeys.googleCalendarClientId,
        GOOGLE_CALENDAR_CLIENT_SECRET: adapterKeys.googleCalendarClientSecret,
        GOOGLE_CALENDAR_ACCESS_TOKEN: adapterKeys.googleCalendarAccessToken,
        GOOGLE_CALENDAR_REFRESH_TOKEN: adapterKeys.googleCalendarRefreshToken,
        CLASH_ROYALE_API_KEY: adapterKeys.clashroyaleApiKey,
        CLASH_ROYALE_PLAYER_TAG: adapterKeys.clashroyalePlayerTag,
      };

      for (const [envKey, value] of Object.entries(adapterKeyMap)) {
        if (value !== undefined && value !== '') {
          envConfig[envKey] = value as string;
        }
      }
    }

    // Write back to file
    const content = serializeEnvFile(envConfig);
    writeFileSync(ENV_PATH, content, 'utf-8');

    const updatedItems = [provider && 'provider', model && 'model', apiKeys && 'apiKeys', adapterKeys && 'adapterKeys'].filter(Boolean);
    console.log(`[Settings API] Updated: ${updatedItems.join(', ')}`);

    return NextResponse.json({
      success: true,
      message: 'Settings saved. Restart services to apply changes.',
      restartRequired: true,
    });
  } catch (error: any) {
    console.error('[Settings API] POST error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to save settings' },
      { status: 500 }
    );
  }
}
