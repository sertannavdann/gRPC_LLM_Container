import { NextRequest, NextResponse } from 'next/server';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';

// Path to .env file in the root workspace
const ENV_PATH = process.env.ENV_FILE_PATH || '/app/.env';

interface EnvConfig {
  LLM_PROVIDER: string;
  LLM_PROVIDER_MODEL: string;
  PERPLEXITY_API_KEY?: string;
  OPENAI_API_KEY?: string;
  ANTHROPIC_API_KEY?: string;
  SERPER_API_KEY?: string;
  // LIDM delegation
  ENABLE_DELEGATION?: string;
  LIDM_HEAVY_MODEL?: string;
  LIDM_STANDARD_MODEL?: string;
  // Adapter keys
  OPENWEATHER_API_KEY?: string;
  OPENWEATHER_CITY?: string;
  GOOGLE_CALENDAR_CLIENT_ID?: string;
  GOOGLE_CALENDAR_CLIENT_SECRET?: string;
  GOOGLE_CALENDAR_ACCESS_TOKEN?: string;
  GOOGLE_CALENDAR_REFRESH_TOKEN?: string;
  CLASH_ROYALE_API_KEY?: string;
  CLASH_ROYALE_PLAYER_TAG?: string;
}

// LIDM: Available models per tier (must exist in llm_service/models/)
const LIDM_TIER_MODELS: Record<string, string[]> = {
  heavy: [
    'Qwen2.5-14B-Instruct-Q4_K.gguf',
    'Mistral-Small-24B-Instruct-2501.Q8_0.gguf',
  ],
  standard: [
    'qwen2.5-0.5b-instruct-q5_k_m.gguf',
  ],
};

// Provider model defaults
const PROVIDER_DEFAULTS: Record<string, { models: string[]; default: string }> = {
  local: {
    models: [
      'qwen2.5-3b-instruct-q5_k_m',
      'Qwen2.5-14B-Instruct-Q4_K',
      'Mistral-Small-24B-Instruct-2501.Q8_0',
      'qwen2.5-0.5b-instruct-q5_k_m',
    ],
    default: 'qwen2.5-3b-instruct-q5_k_m',
  },
  perplexity: {
    models: ['sonar-pro', 'sonar', 'sonar-deep-research'],
    default: 'sonar-pro',
  },
  openai: {
    models: ['gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo', 'gpt-3.5-turbo'],
    default: 'gpt-4o-mini',
  },
  anthropic: {
    models: ['claude-3-5-sonnet-20241022', 'claude-3-opus-20240229', 'claude-3-haiku-20240307'],
    default: 'claude-3-5-sonnet-20241022',
  },
};

function parseEnvFile(content: string): Record<string, string> {
  const result: Record<string, string> = {};
  const lines = content.split('\n');
  
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) continue;
    
    const key = trimmed.substring(0, eqIndex).trim();
    const value = trimmed.substring(eqIndex + 1).trim();
    result[key] = value;
  }
  
  return result;
}

function serializeEnvFile(config: Record<string, string>): string {
  const lines: string[] = [
    '# gRPC LLM Agent Framework - Environment Configuration',
    '# Auto-generated by UI settings',
    '',
  ];
  
  for (const [key, value] of Object.entries(config)) {
    if (value) {
      lines.push(`${key}=${value}`);
    }
  }
  
  return lines.join('\n') + '\n';
}

// GET - Read current settings
export async function GET() {
  try {
    let envConfig: Record<string, string> = {};
    
    if (existsSync(ENV_PATH)) {
      const content = readFileSync(ENV_PATH, 'utf-8');
      envConfig = parseEnvFile(content);
    }
    
    const currentProvider = envConfig.LLM_PROVIDER || 'local';
    
    // Filter providers: always include 'local', only include cloud providers with API keys
    const providerKeyMap: Record<string, string> = {
      perplexity: 'PERPLEXITY_API_KEY',
      openai: 'OPENAI_API_KEY',
      anthropic: 'ANTHROPIC_API_KEY',
    };

    const availableProviders: Record<string, { models: string[]; default: string }> = {};
    for (const [name, info] of Object.entries(PROVIDER_DEFAULTS)) {
      if (name === 'local' || envConfig[providerKeyMap[name]]) {
        availableProviders[name] = info;
      }
    }

    // If current provider is not in available list, fall back to 'local'
    const effectiveProvider = availableProviders[currentProvider] ? currentProvider : 'local';
    const effectiveModel = effectiveProvider === currentProvider
      ? envConfig.LLM_PROVIDER_MODEL || PROVIDER_DEFAULTS[currentProvider]?.default || ''
      : PROVIDER_DEFAULTS.local.default;

    return NextResponse.json({
      config: {
        provider: effectiveProvider,
        model: effectiveModel,
        hasPerplexityKey: !!envConfig.PERPLEXITY_API_KEY,
        hasOpenaiKey: !!envConfig.OPENAI_API_KEY,
        hasAnthropicKey: !!envConfig.ANTHROPIC_API_KEY,
        hasSerperKey: !!envConfig.SERPER_API_KEY,
        // LIDM delegation
        delegationEnabled: (envConfig.ENABLE_DELEGATION || 'false').toLowerCase() === 'true',
        lidmHeavyModel: envConfig.LIDM_HEAVY_MODEL || 'Qwen2.5-14B-Instruct-Q4_K.gguf',
        lidmStandardModel: envConfig.LIDM_STANDARD_MODEL || 'qwen2.5-0.5b-instruct-q5_k_m.gguf',
      },
      lidmTierModels: LIDM_TIER_MODELS,
      adapters: {
        openweather: {
          hasApiKey: !!envConfig.OPENWEATHER_API_KEY,
          city: envConfig.OPENWEATHER_CITY || 'Toronto,CA',
        },
        google_calendar: {
          hasClientId: !!envConfig.GOOGLE_CALENDAR_CLIENT_ID,
          hasClientSecret: !!envConfig.GOOGLE_CALENDAR_CLIENT_SECRET,
          hasAccessToken: !!envConfig.GOOGLE_CALENDAR_ACCESS_TOKEN,
          hasRefreshToken: !!envConfig.GOOGLE_CALENDAR_REFRESH_TOKEN,
          connected: !!(envConfig.GOOGLE_CALENDAR_ACCESS_TOKEN && envConfig.GOOGLE_CALENDAR_REFRESH_TOKEN),
        },
        clashroyale: {
          hasApiKey: !!envConfig.CLASH_ROYALE_API_KEY,
          playerTag: envConfig.CLASH_ROYALE_PLAYER_TAG || '',
        },
      },
      providers: availableProviders,
    });
  } catch (error: any) {
    console.error('[Settings API] GET error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to read settings' },
      { status: 500 }
    );
  }
}

// POST - Update settings
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { provider, model, apiKeys, adapterKeys, delegation } = body;

    // Read existing config
    let envConfig: Record<string, string> = {};
    if (existsSync(ENV_PATH)) {
      const content = readFileSync(ENV_PATH, 'utf-8');
      envConfig = parseEnvFile(content);
    }

    // Update provider and model
    if (provider) {
      envConfig.LLM_PROVIDER = provider;
    }
    if (model) {
      envConfig.LLM_PROVIDER_MODEL = model;
    }

    // Update LIDM delegation settings
    if (delegation !== undefined) {
      envConfig.ENABLE_DELEGATION = delegation.enabled ? 'true' : 'false';
      if (delegation.heavyModel) envConfig.LIDM_HEAVY_MODEL = delegation.heavyModel;
      if (delegation.standardModel) envConfig.LIDM_STANDARD_MODEL = delegation.standardModel;
    }

    // Update LLM API keys (only if provided - don't overwrite with empty)
    if (apiKeys) {
      if (apiKeys.perplexity) envConfig.PERPLEXITY_API_KEY = apiKeys.perplexity;
      if (apiKeys.openai) envConfig.OPENAI_API_KEY = apiKeys.openai;
      if (apiKeys.anthropic) envConfig.ANTHROPIC_API_KEY = apiKeys.anthropic;
      if (apiKeys.serper) envConfig.SERPER_API_KEY = apiKeys.serper;
    }

    // Update adapter keys (only non-empty values)
    if (adapterKeys) {
      const adapterKeyMap: Record<string, string> = {
        OPENWEATHER_API_KEY: adapterKeys.openweatherApiKey,
        OPENWEATHER_CITY: adapterKeys.openweatherCity,
        GOOGLE_CALENDAR_CLIENT_ID: adapterKeys.googleCalendarClientId,
        GOOGLE_CALENDAR_CLIENT_SECRET: adapterKeys.googleCalendarClientSecret,
        GOOGLE_CALENDAR_ACCESS_TOKEN: adapterKeys.googleCalendarAccessToken,
        GOOGLE_CALENDAR_REFRESH_TOKEN: adapterKeys.googleCalendarRefreshToken,
        CLASH_ROYALE_API_KEY: adapterKeys.clashroyaleApiKey,
        CLASH_ROYALE_PLAYER_TAG: adapterKeys.clashroyalePlayerTag,
      };

      for (const [envKey, value] of Object.entries(adapterKeyMap)) {
        if (value !== undefined && value !== '') {
          envConfig[envKey] = value as string;
        }
      }
    }

    // Write back to file
    const content = serializeEnvFile(envConfig);
    writeFileSync(ENV_PATH, content, 'utf-8');

    const updatedItems = [provider && 'provider', model && 'model', apiKeys && 'apiKeys', adapterKeys && 'adapterKeys'].filter(Boolean);
    console.log(`[Settings API] Updated: ${updatedItems.join(', ')}`);

    return NextResponse.json({
      success: true,
      message: 'Settings saved. Restart services to apply changes.',
      restartRequired: true,
    });
  } catch (error: any) {
    console.error('[Settings API] POST error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to save settings' },
      { status: 500 }
    );
  }
}
